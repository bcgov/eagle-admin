import { ConnectionPositionPair, CdkConnectedOverlay, CdkOverlayOrigin } from '@angular/cdk/overlay';
import * as i0 from '@angular/core';
import { inject, ElementRef, booleanAttribute, Input, Directive, NgModule } from '@angular/core';
import { takeUntilDestroyed } from '@angular/core/rxjs-interop';

/**
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE
 */
const POSITION_MAP = {
    top: new ConnectionPositionPair({ originX: 'center', originY: 'top' }, { overlayX: 'center', overlayY: 'bottom' }),
    topCenter: new ConnectionPositionPair({ originX: 'center', originY: 'top' }, { overlayX: 'center', overlayY: 'bottom' }),
    topLeft: new ConnectionPositionPair({ originX: 'start', originY: 'top' }, { overlayX: 'start', overlayY: 'bottom' }),
    topRight: new ConnectionPositionPair({ originX: 'end', originY: 'top' }, { overlayX: 'end', overlayY: 'bottom' }),
    right: new ConnectionPositionPair({ originX: 'end', originY: 'center' }, { overlayX: 'start', overlayY: 'center' }),
    rightTop: new ConnectionPositionPair({ originX: 'end', originY: 'top' }, { overlayX: 'start', overlayY: 'top' }),
    rightBottom: new ConnectionPositionPair({ originX: 'end', originY: 'bottom' }, { overlayX: 'start', overlayY: 'bottom' }),
    bottom: new ConnectionPositionPair({ originX: 'center', originY: 'bottom' }, { overlayX: 'center', overlayY: 'top' }),
    bottomCenter: new ConnectionPositionPair({ originX: 'center', originY: 'bottom' }, { overlayX: 'center', overlayY: 'top' }),
    bottomLeft: new ConnectionPositionPair({ originX: 'start', originY: 'bottom' }, { overlayX: 'start', overlayY: 'top' }),
    bottomRight: new ConnectionPositionPair({ originX: 'end', originY: 'bottom' }, { overlayX: 'end', overlayY: 'top' }),
    left: new ConnectionPositionPair({ originX: 'start', originY: 'center' }, { overlayX: 'end', overlayY: 'center' }),
    leftTop: new ConnectionPositionPair({ originX: 'start', originY: 'top' }, { overlayX: 'end', overlayY: 'top' }),
    leftBottom: new ConnectionPositionPair({ originX: 'start', originY: 'bottom' }, { overlayX: 'end', overlayY: 'bottom' })
};
/**
 * @internal
 * @param offset offset in pixels which should not be less than 0.
 * The default value is `12`, which means `(arrow-size / 2) + 4`
 */
const positionOffsetMapFactory = (offset = 12) => ({
    top: [0, -offset],
    topCenter: [0, -offset],
    topLeft: [0, -offset],
    topRight: [0, -offset],
    right: [offset, 0],
    rightTop: [offset, 0],
    rightBottom: [offset, 0],
    bottom: [0, offset],
    bottomCenter: [0, offset],
    bottomLeft: [0, offset],
    bottomRight: [0, offset],
    left: [-offset, 0],
    leftTop: [-offset, 0],
    leftBottom: [-offset, 0]
});
const TOOLTIP_OFFSET_MAP = positionOffsetMapFactory();
const DEFAULT_TOOLTIP_POSITIONS = [
    setConnectedPositionOffset(POSITION_MAP.top, TOOLTIP_OFFSET_MAP.top),
    setConnectedPositionOffset(POSITION_MAP.right, TOOLTIP_OFFSET_MAP.right),
    setConnectedPositionOffset(POSITION_MAP.bottom, TOOLTIP_OFFSET_MAP.bottom),
    setConnectedPositionOffset(POSITION_MAP.left, TOOLTIP_OFFSET_MAP.left)
];
const DEFAULT_CASCADER_POSITIONS = [
    POSITION_MAP.bottomLeft,
    POSITION_MAP.bottomRight,
    POSITION_MAP.topLeft,
    POSITION_MAP.topRight
];
const DEFAULT_MENTION_TOP_POSITIONS = [
    new ConnectionPositionPair({ originX: 'start', originY: 'bottom' }, { overlayX: 'start', overlayY: 'bottom' }),
    new ConnectionPositionPair({ originX: 'start', originY: 'bottom' }, { overlayX: 'end', overlayY: 'bottom' })
];
const DEFAULT_MENTION_BOTTOM_POSITIONS = [
    POSITION_MAP.bottomLeft,
    new ConnectionPositionPair({ originX: 'start', originY: 'bottom' }, { overlayX: 'end', overlayY: 'top' })
];
function getPlacementName(position) {
    for (const placement in POSITION_MAP) {
        if (position.connectionPair.originX === POSITION_MAP[placement].originX &&
            position.connectionPair.originY === POSITION_MAP[placement].originY &&
            position.connectionPair.overlayX === POSITION_MAP[placement].overlayX &&
            position.connectionPair.overlayY === POSITION_MAP[placement].overlayY) {
            return placement;
        }
    }
    return undefined;
}
const DATE_PICKER_POSITION_MAP = {
    bottomLeft: new ConnectionPositionPair({ originX: 'start', originY: 'bottom' }, { overlayX: 'start', overlayY: 'top' }, undefined, 2),
    topLeft: new ConnectionPositionPair({ originX: 'start', originY: 'top' }, { overlayX: 'start', overlayY: 'bottom' }, undefined, -2),
    bottomRight: new ConnectionPositionPair({ originX: 'end', originY: 'bottom' }, { overlayX: 'end', overlayY: 'top' }, undefined, 2),
    topRight: new ConnectionPositionPair({ originX: 'end', originY: 'top' }, { overlayX: 'end', overlayY: 'bottom' }, undefined, -2)
};
const DEFAULT_DATE_PICKER_POSITIONS = [
    DATE_PICKER_POSITION_MAP.bottomLeft,
    DATE_PICKER_POSITION_MAP.topLeft,
    DATE_PICKER_POSITION_MAP.bottomRight,
    DATE_PICKER_POSITION_MAP.topRight
];
function normalizeConnectedPositionOffset(offset) {
    return Array.isArray(offset) ? offset : [offset, offset];
}
function setConnectedPositionOffset(position, offset) {
    const [offsetX, offsetY] = normalizeConnectedPositionOffset(offset);
    // return new object
    return {
        ...position,
        offsetX: offsetX,
        offsetY: offsetY
    };
}

/**
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE
 */
class NzConnectedOverlayDirective {
    cdkConnectedOverlay = inject(CdkConnectedOverlay);
    nzArrowPointAtCenter = false;
    constructor() {
        this.cdkConnectedOverlay.backdropClass = 'nz-overlay-transparent-backdrop';
        this.cdkConnectedOverlay.positionChange.pipe(takeUntilDestroyed()).subscribe(position => {
            if (this.nzArrowPointAtCenter) {
                this.updateArrowPosition(position);
            }
        });
    }
    updateArrowPosition(position) {
        const originRect = this.getOriginRect();
        const placement = getPlacementName(position);
        let offsetX = 0;
        let offsetY = 0;
        if (placement === 'topLeft' || placement === 'bottomLeft') {
            offsetX = originRect.width / 2 - 14;
        }
        else if (placement === 'topRight' || placement === 'bottomRight') {
            offsetX = -(originRect.width / 2 - 14);
        }
        else if (placement === 'leftTop' || placement === 'rightTop') {
            offsetY = originRect.height / 2 - 10;
        }
        else if (placement === 'leftBottom' || placement === 'rightBottom') {
            offsetY = -(originRect.height / 2 - 10);
        }
        if (this.cdkConnectedOverlay.offsetX !== offsetX || this.cdkConnectedOverlay.offsetY !== offsetY) {
            this.cdkConnectedOverlay.offsetY = offsetY;
            this.cdkConnectedOverlay.offsetX = offsetX;
            this.cdkConnectedOverlay.overlayRef.updatePosition();
        }
    }
    getFlexibleConnectedPositionStrategyOrigin() {
        if (this.cdkConnectedOverlay.origin instanceof CdkOverlayOrigin) {
            return this.cdkConnectedOverlay.origin.elementRef;
        }
        else {
            return this.cdkConnectedOverlay.origin;
        }
    }
    getOriginRect() {
        const origin = this.getFlexibleConnectedPositionStrategyOrigin();
        if (origin instanceof ElementRef) {
            return origin.nativeElement.getBoundingClientRect();
        }
        // Check for Element so SVG elements are also supported.
        if (origin instanceof Element) {
            return origin.getBoundingClientRect();
        }
        const width = origin.width || 0;
        const height = origin.height || 0;
        // If the origin is a point, return a client rect as if it was a 0x0 element at the point.
        return {
            top: origin.y,
            bottom: origin.y + height,
            left: origin.x,
            right: origin.x + width,
            height,
            width
        };
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "21.0.0", ngImport: i0, type: NzConnectedOverlayDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "16.1.0", version: "21.0.0", type: NzConnectedOverlayDirective, isStandalone: true, selector: "[cdkConnectedOverlay][nzConnectedOverlay]", inputs: { nzArrowPointAtCenter: ["nzArrowPointAtCenter", "nzArrowPointAtCenter", booleanAttribute] }, exportAs: ["nzConnectedOverlay"], ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "21.0.0", ngImport: i0, type: NzConnectedOverlayDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cdkConnectedOverlay][nzConnectedOverlay]',
                    exportAs: 'nzConnectedOverlay'
                }]
        }], ctorParameters: () => [], propDecorators: { nzArrowPointAtCenter: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }] } });

/**
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE
 */
class NzOverlayModule {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "21.0.0", ngImport: i0, type: NzOverlayModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "21.0.0", ngImport: i0, type: NzOverlayModule, imports: [NzConnectedOverlayDirective], exports: [NzConnectedOverlayDirective] });
    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "21.0.0", ngImport: i0, type: NzOverlayModule });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "21.0.0", ngImport: i0, type: NzOverlayModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [NzConnectedOverlayDirective],
                    exports: [NzConnectedOverlayDirective]
                }]
        }] });

/**
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE
 */
function overlayZIndexSetter(overlayRef, zIndex) {
    if (!zIndex)
        return;
    overlayRef['_host'].style.zIndex = `${zIndex}`;
}

/**
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE
 */

/**
 * Generated bundle index. Do not edit.
 */

export { DATE_PICKER_POSITION_MAP, DEFAULT_CASCADER_POSITIONS, DEFAULT_DATE_PICKER_POSITIONS, DEFAULT_MENTION_BOTTOM_POSITIONS, DEFAULT_MENTION_TOP_POSITIONS, DEFAULT_TOOLTIP_POSITIONS, NzConnectedOverlayDirective, NzOverlayModule, POSITION_MAP, TOOLTIP_OFFSET_MAP, getPlacementName, normalizeConnectedPositionOffset, overlayZIndexSetter, setConnectedPositionOffset };
//# sourceMappingURL=ng-zorro-antd-core-overlay.mjs.map
