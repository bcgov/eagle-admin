import { LEFT_ARROW, RIGHT_ARROW, UP_ARROW, DOWN_ARROW } from '@angular/cdk/keycodes';
import { NgTemplateOutlet } from '@angular/common';
import * as i0 from '@angular/core';
import { inject, signal, computed, DestroyRef, Injectable, ElementRef, viewChild, TemplateRef, input, booleanAttribute, ViewEncapsulation, ChangeDetectionStrategy, Component, Injector, EventEmitter, viewChildren, contentChildren, afterNextRender, effect, forwardRef, Output, Input, NgModule } from '@angular/core';
import { toSignal, takeUntilDestroyed } from '@angular/core/rxjs-interop';
import { ReplaySubject, Subject, BehaviorSubject, of } from 'rxjs';
import { tap, switchMap, filter, take, map } from 'rxjs/operators';
import * as i1 from 'ng-zorro-antd/icon';
import { NzIconModule } from 'ng-zorro-antd/icon';
import { _IdGenerator } from '@angular/cdk/a11y';
import { isAnimationEnabled, withAnimationCheck } from 'ng-zorro-antd/core/animation';
import { __esDecorate, __runInitializers } from 'tslib';
import { Directionality } from '@angular/cdk/bidi';
import { NG_VALUE_ACCESSOR } from '@angular/forms';
import { WithConfig } from 'ng-zorro-antd/core/config';
import { NzOutletModule } from 'ng-zorro-antd/core/outlet';
import { requestAnimationFrame } from 'ng-zorro-antd/core/polyfill';

/**
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE
 */
class NzSegmentedService {
    defaultName = inject(_IdGenerator).getId('segmented_');
    name = signal(this.defaultName, ...(ngDevMode ? [{ debugName: "name" }] : []));
    selected$ = new ReplaySubject(1);
    activated$ = new ReplaySubject(1);
    change$ = new Subject();
    disabled$ = new ReplaySubject(1);
    animating$ = new BehaviorSubject(false);
    keydown$ = new Subject();
    _animating = toSignal(this.animating$, { initialValue: false });
    animationEnabled = isAnimationEnabled(() => true);
    showThumb = computed(() => this.animationEnabled() && this._animating(), ...(ngDevMode ? [{ debugName: "showThumb" }] : []));
    constructor() {
        inject(DestroyRef).onDestroy(() => {
            this.selected$.complete();
            this.activated$.complete();
            this.change$.complete();
            this.disabled$.complete();
            this.animating$.complete();
            this.keydown$.complete();
        });
    }
    setName(name) {
        this.name.set(typeof name === 'undefined' ? this.defaultName : name);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "21.0.0", ngImport: i0, type: NzSegmentedService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "21.0.0", ngImport: i0, type: NzSegmentedService });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "21.0.0", ngImport: i0, type: NzSegmentedService, decorators: [{
            type: Injectable
        }], ctorParameters: () => [] });

/**
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE
 */
class NzSegmentedItemComponent {
    service = inject(NzSegmentedService);
    elementRef = inject(ElementRef);
    destroyRef = inject(DestroyRef);
    templateRef = viewChild.required('content', { read: TemplateRef });
    nzValue = input.required(...(ngDevMode ? [{ debugName: "nzValue" }] : []));
    nzIcon = input(...(ngDevMode ? [undefined, { debugName: "nzIcon" }] : []));
    nzDisabled = input(false, ...(ngDevMode ? [{ debugName: "nzDisabled", transform: booleanAttribute }] : [{ transform: booleanAttribute }]));
    hasLabel = computed(() => this.templateRef()
        .createEmbeddedView({})
        .rootNodes.some(node => node.textContent.trim().length > 0), ...(ngDevMode ? [{ debugName: "hasLabel" }] : []));
    showThumb = this.service.showThumb;
    name = this.service.name.asReadonly();
    isChecked = signal(false, ...(ngDevMode ? [{ debugName: "isChecked" }] : []));
    parentDisabled = toSignal(this.service.disabled$, { initialValue: false });
    finalDisabled = computed(() => this.nzDisabled() || this.parentDisabled(), ...(ngDevMode ? [{ debugName: "finalDisabled" }] : []));
    ngOnInit() {
        this.service.selected$
            .pipe(tap(value => {
            this.isChecked.set(false);
            if (value === this.nzValue()) {
                this.service.activated$.next(this.elementRef.nativeElement);
            }
        }), switchMap(value => {
            if (!this.service.animationEnabled()) {
                return of(value);
            }
            return this.service.animating$.pipe(filter(animating => !animating), // done
            take(1), map(() => value));
        }), filter(value => value === this.nzValue()), takeUntilDestroyed(this.destroyRef))
            .subscribe(() => this.isChecked.set(true));
    }
    handleClick() {
        if (!this.nzDisabled() && !this.parentDisabled()) {
            this.service.selected$.next(this.nzValue());
            this.service.change$.next(this.nzValue());
        }
    }
    handleKeydown(event) {
        if (this.finalDisabled()) {
            return;
        }
        if (event.keyCode === LEFT_ARROW ||
            event.keyCode === RIGHT_ARROW ||
            event.keyCode === UP_ARROW ||
            event.keyCode === DOWN_ARROW) {
            this.service.keydown$.next(event);
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "21.0.0", ngImport: i0, type: NzSegmentedItemComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "21.0.0", type: NzSegmentedItemComponent, isStandalone: true, selector: "label[nz-segmented-item],label[nzSegmentedItem]", inputs: { nzValue: { classPropertyName: "nzValue", publicName: "nzValue", isSignal: true, isRequired: true, transformFunction: null }, nzIcon: { classPropertyName: "nzIcon", publicName: "nzIcon", isSignal: true, isRequired: false, transformFunction: null }, nzDisabled: { classPropertyName: "nzDisabled", publicName: "nzDisabled", isSignal: true, isRequired: false, transformFunction: null } }, host: { listeners: { "click": "handleClick()", "keydown": "handleKeydown($event)" }, properties: { "class.ant-segmented-item-selected": "!showThumb() && isChecked()", "class.ant-segmented-item-disabled": "finalDisabled()" }, classAttribute: "ant-segmented-item" }, viewQueries: [{ propertyName: "templateRef", first: true, predicate: ["content"], descendants: true, read: TemplateRef, isSignal: true }], exportAs: ["nzSegmentedItem"], ngImport: i0, template: `
    <input
      class="ant-segmented-item-input"
      type="radio"
      [disabled]="finalDisabled()"
      [checked]="isChecked()"
      [attr.name]="name()"
      (click)="$event.stopPropagation()"
    />
    <div class="ant-segmented-item-label" [attr.aria-selected]="isChecked()">
      @if (nzIcon(); as icon) {
        <span class="ant-segmented-item-icon">
          <nz-icon [nzType]="icon" />
        </span>
        @if (hasLabel()) {
          <span>
            <ng-template [ngTemplateOutlet]="content" />
          </span>
        }
      } @else {
        <ng-template [ngTemplateOutlet]="content" />
      }
    </div>

    <ng-template #content>
      <ng-content></ng-content>
    </ng-template>
  `, isInline: true, dependencies: [{ kind: "ngmodule", type: NzIconModule }, { kind: "directive", type: i1.NzIconDirective, selector: "nz-icon,[nz-icon]", inputs: ["nzSpin", "nzRotate", "nzType", "nzTheme", "nzTwotoneColor", "nzIconfont"], exportAs: ["nzIcon"] }, { kind: "directive", type: NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush, encapsulation: i0.ViewEncapsulation.None });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "21.0.0", ngImport: i0, type: NzSegmentedItemComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'label[nz-segmented-item],label[nzSegmentedItem]',
                    exportAs: 'nzSegmentedItem',
                    imports: [NzIconModule, NgTemplateOutlet],
                    template: `
    <input
      class="ant-segmented-item-input"
      type="radio"
      [disabled]="finalDisabled()"
      [checked]="isChecked()"
      [attr.name]="name()"
      (click)="$event.stopPropagation()"
    />
    <div class="ant-segmented-item-label" [attr.aria-selected]="isChecked()">
      @if (nzIcon(); as icon) {
        <span class="ant-segmented-item-icon">
          <nz-icon [nzType]="icon" />
        </span>
        @if (hasLabel()) {
          <span>
            <ng-template [ngTemplateOutlet]="content" />
          </span>
        }
      } @else {
        <ng-template [ngTemplateOutlet]="content" />
      }
    </div>

    <ng-template #content>
      <ng-content></ng-content>
    </ng-template>
  `,
                    host: {
                        class: 'ant-segmented-item',
                        '[class.ant-segmented-item-selected]': '!showThumb() && isChecked()',
                        '[class.ant-segmented-item-disabled]': 'finalDisabled()',
                        '(click)': 'handleClick()',
                        '(keydown)': 'handleKeydown($event)'
                    },
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    encapsulation: ViewEncapsulation.None
                }]
        }], propDecorators: { templateRef: [{ type: i0.ViewChild, args: ['content', { ...{ read: TemplateRef }, isSignal: true }] }], nzValue: [{ type: i0.Input, args: [{ isSignal: true, alias: "nzValue", required: true }] }], nzIcon: [{ type: i0.Input, args: [{ isSignal: true, alias: "nzIcon", required: false }] }], nzDisabled: [{ type: i0.Input, args: [{ isSignal: true, alias: "nzDisabled", required: false }] }] } });

/**
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE
 */
function normalizeOptions(unnormalized) {
    return unnormalized.map(item => {
        if (typeof item === 'string' || typeof item === 'number') {
            return {
                label: `${item}`,
                value: item
            };
        }
        return item;
    });
}

const NZ_CONFIG_MODULE_NAME = 'segmented';
let NzSegmentedComponent = (() => {
    let _nzSize_decorators;
    let _nzSize_initializers = [];
    let _nzSize_extraInitializers = [];
    return class NzSegmentedComponent {
        static {
            const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(null) : void 0;
            _nzSize_decorators = [WithConfig()];
            __esDecorate(null, null, _nzSize_decorators, { kind: "field", name: "nzSize", static: false, private: false, access: { has: obj => "nzSize" in obj, get: obj => obj.nzSize, set: (obj, value) => { obj.nzSize = value; } }, metadata: _metadata }, _nzSize_initializers, _nzSize_extraInitializers);
            if (_metadata) Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
        }
        _nzModuleName = NZ_CONFIG_MODULE_NAME;
        service = inject(NzSegmentedService);
        injector = inject(Injector);
        dir = inject(Directionality).valueSignal;
        nzBlock = false;
        nzDisabled = false;
        nzOptions = [];
        nzVertical = false;
        nzShape = 'default';
        nzSize = __runInitializers(this, _nzSize_initializers, 'default');
        /**
         * @description set the `name` attribute of the segmented item native `input[type="radio"]`
         * @since 20.3.0
         */
        nzName = __runInitializers(this, _nzSize_extraInitializers);
        nzValueChange = new EventEmitter();
        viewItemCmps = viewChildren(NzSegmentedItemComponent, ...(ngDevMode ? [{ debugName: "viewItemCmps" }] : []));
        contentItemCmps = contentChildren(NzSegmentedItemComponent, ...(ngDevMode ? [{ debugName: "contentItemCmps" }] : []));
        renderedItemCmps = computed(() => this.viewItemCmps().concat(this.contentItemCmps()), ...(ngDevMode ? [{ debugName: "renderedItemCmps" }] : []));
        isDisabledFirstChange = true;
        value;
        thumbStyle = signal(null, ...(ngDevMode ? [{ debugName: "thumbStyle" }] : []));
        thumbAnimationEnter = withAnimationCheck(() => 'ant-segmented-thumb-motion-appear-active');
        showThumb = this.service.showThumb;
        normalizedOptions = [];
        onChange = () => { };
        onTouched = () => { };
        constructor() {
            this.service.selected$.pipe(takeUntilDestroyed()).subscribe(value => {
                this.value = value;
            });
            this.service.activated$.pipe(takeUntilDestroyed()).subscribe(element => {
                this.thumbStyle.update(prevStyle => {
                    const nextStyle = this.calcThumbStyle(element);
                    if (prevStyle && nextStyle) {
                        // Trigger animation to end position
                        requestAnimationFrame(() => {
                            this.thumbStyle.set(this.getThumbStyle(nextStyle));
                        });
                    }
                    else if (nextStyle) {
                        return this.getThumbStyle(nextStyle);
                    }
                    return prevStyle;
                });
            });
            this.service.change$.pipe(takeUntilDestroyed()).subscribe(value => {
                this.nzValueChange.emit(value);
                this.onChange(value);
                this.service.animating$.next(true);
            });
            this.service.keydown$
                .pipe(filter(() => !this.nzDisabled), takeUntilDestroyed())
                .subscribe(event => this.onKeyDown(event));
            afterNextRender(() => {
                effect(() => {
                    const itemCmps = this.renderedItemCmps();
                    if (!itemCmps.length) {
                        return;
                    }
                    if (this.value === undefined || // If no value is set, select the first item
                        !itemCmps.some(item => item.nzValue() === this.value) // handle value not in options
                    ) {
                        this.service.selected$.next(itemCmps[0].nzValue());
                    }
                }, { injector: this.injector });
            });
        }
        ngOnChanges(changes) {
            const { nzName, nzOptions, nzDisabled } = changes;
            if (nzName) {
                this.service.setName(this.nzName);
            }
            if (nzOptions) {
                this.normalizedOptions = normalizeOptions(nzOptions.currentValue);
            }
            if (nzDisabled) {
                this.service.disabled$.next(nzDisabled.currentValue);
            }
        }
        onOffset(offset) {
            const items = this.renderedItemCmps();
            const total = items.length;
            const originIndex = items.findIndex(item => item.nzValue() === this.value);
            let nextIndex = (originIndex + offset + total) % total;
            // find out the next non-disabled item
            while (items[nextIndex].nzDisabled()) {
                nextIndex = (nextIndex + Math.sign(offset) + total) % total;
                // avoid circular loop
                if (nextIndex === originIndex) {
                    break;
                }
            }
            const nextOption = items[nextIndex];
            if (nextOption) {
                this.service.selected$.next(nextOption.nzValue());
                this.service.change$.next(nextOption.nzValue());
            }
        }
        // change selected item by direction keyboard interaction
        onKeyDown(event) {
            switch (event.keyCode) {
                case UP_ARROW:
                    this.onOffset(-1);
                    break;
                case LEFT_ARROW:
                    this.onOffset(this.dir() === 'rtl' ? 1 : -1);
                    break;
                case DOWN_ARROW:
                    this.onOffset(1);
                    break;
                case RIGHT_ARROW:
                    this.onOffset(this.dir() === 'rtl' ? -1 : 1);
                    break;
            }
        }
        writeValue(value) {
            this.service.selected$.next(value);
        }
        registerOnChange(fn) {
            this.onChange = fn;
        }
        registerOnTouched(fn) {
            this.onTouched = fn;
        }
        setDisabledState(disabled) {
            this.nzDisabled = (this.isDisabledFirstChange && this.nzDisabled) || disabled;
            this.isDisabledFirstChange = false;
        }
        /************* Thumb Animation *************/
        calcThumbStyle(element) {
            if (!element || !element.offsetParent) {
                return null;
            }
            const parentElement = element.parentElement;
            if (!parentElement) {
                return null;
            }
            const style = {
                left: element.offsetLeft,
                right: parentElement.clientWidth - element.clientWidth - element.offsetLeft,
                width: element.clientWidth,
                top: element.offsetTop,
                bottom: parentElement.clientHeight - element.clientHeight - element.offsetTop,
                height: element.clientHeight
            };
            if (this.nzVertical) {
                return {
                    left: 0,
                    right: 0,
                    width: 0,
                    top: style.top,
                    bottom: style.bottom,
                    height: style.height
                };
            }
            return {
                left: style.left,
                right: style.right,
                width: style.width,
                top: 0,
                bottom: 0,
                height: 0
            };
        }
        getThumbStyle(targetStyle) {
            if (this.nzVertical) {
                return {
                    transform: `translateY(${targetStyle.top}px)`,
                    width: '100%',
                    height: `${targetStyle.height}px`
                };
            }
            const isRtl = this.dir() === 'rtl';
            const transformValue = isRtl ? -targetStyle.right : targetStyle.left;
            return {
                transform: `translateX(${transformValue}px)`,
                width: `${targetStyle.width}px`,
                height: '100%'
            };
        }
        handleTransitionEnd(event) {
            if (event.propertyName === 'transform') {
                this.service.animating$.next(false);
            }
        }
        static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "21.0.0", ngImport: i0, type: NzSegmentedComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
        static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "21.0.0", type: NzSegmentedComponent, isStandalone: true, selector: "nz-segmented", inputs: { nzBlock: ["nzBlock", "nzBlock", booleanAttribute], nzDisabled: ["nzDisabled", "nzDisabled", booleanAttribute], nzOptions: "nzOptions", nzVertical: ["nzVertical", "nzVertical", booleanAttribute], nzShape: "nzShape", nzSize: "nzSize", nzName: "nzName" }, outputs: { nzValueChange: "nzValueChange" }, host: { attributes: { "role": "radiogroup", "aria-label": "segmented control" }, properties: { "class.ant-segmented-disabled": "nzDisabled", "class.ant-segmented-rtl": "dir() === 'rtl'", "class.ant-segmented-lg": "nzSize === 'large'", "class.ant-segmented-sm": "nzSize === 'small'", "class.ant-segmented-block": "nzBlock", "class.ant-segmented-vertical": "nzVertical", "class.ant-segmented-shape-round": "nzShape === 'round'", "attr.tabindex": "nzDisabled ? undefined : 0" }, classAttribute: "ant-segmented" }, providers: [
                NzSegmentedService,
                {
                    provide: NG_VALUE_ACCESSOR,
                    useExisting: forwardRef(() => NzSegmentedComponent),
                    multi: true
                }
            ], queries: [{ propertyName: "contentItemCmps", predicate: NzSegmentedItemComponent, isSignal: true }], viewQueries: [{ propertyName: "viewItemCmps", predicate: NzSegmentedItemComponent, descendants: true, isSignal: true }], exportAs: ["nzSegmented"], usesOnChanges: true, ngImport: i0, template: `
    <!-- thumb motion div -->
    <div class="ant-segmented-group">
      @if (showThumb()) {
        <div
          class="ant-segmented-thumb"
          [style]="thumbStyle()"
          [animate.enter]="thumbAnimationEnter()"
          (transitionend)="handleTransitionEnd($event)"
        ></div>
      }

      <ng-content>
        @for (item of normalizedOptions; track item.value) {
          <label nz-segmented-item [nzIcon]="item.icon" [nzValue]="item.value" [nzDisabled]="item.disabled">
            {{ item.label }}
          </label>
        }
      </ng-content>
    </div>
  `, isInline: true, dependencies: [{ kind: "ngmodule", type: NzIconModule }, { kind: "ngmodule", type: NzOutletModule }, { kind: "component", type: NzSegmentedItemComponent, selector: "label[nz-segmented-item],label[nzSegmentedItem]", inputs: ["nzValue", "nzIcon", "nzDisabled"], exportAs: ["nzSegmentedItem"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush, encapsulation: i0.ViewEncapsulation.None });
    };
})();
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "21.0.0", ngImport: i0, type: NzSegmentedComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    encapsulation: ViewEncapsulation.None,
                    selector: 'nz-segmented',
                    exportAs: 'nzSegmented',
                    template: `
    <!-- thumb motion div -->
    <div class="ant-segmented-group">
      @if (showThumb()) {
        <div
          class="ant-segmented-thumb"
          [style]="thumbStyle()"
          [animate.enter]="thumbAnimationEnter()"
          (transitionend)="handleTransitionEnd($event)"
        ></div>
      }

      <ng-content>
        @for (item of normalizedOptions; track item.value) {
          <label nz-segmented-item [nzIcon]="item.icon" [nzValue]="item.value" [nzDisabled]="item.disabled">
            {{ item.label }}
          </label>
        }
      </ng-content>
    </div>
  `,
                    host: {
                        class: 'ant-segmented',
                        '[class.ant-segmented-disabled]': 'nzDisabled',
                        '[class.ant-segmented-rtl]': `dir() === 'rtl'`,
                        '[class.ant-segmented-lg]': `nzSize === 'large'`,
                        '[class.ant-segmented-sm]': `nzSize === 'small'`,
                        '[class.ant-segmented-block]': `nzBlock`,
                        '[class.ant-segmented-vertical]': `nzVertical`,
                        '[class.ant-segmented-shape-round]': `nzShape === 'round'`,
                        // a11y
                        role: 'radiogroup',
                        'aria-label': 'segmented control',
                        '[attr.tabindex]': 'nzDisabled ? undefined : 0'
                    },
                    providers: [
                        NzSegmentedService,
                        {
                            provide: NG_VALUE_ACCESSOR,
                            useExisting: forwardRef(() => NzSegmentedComponent),
                            multi: true
                        }
                    ],
                    imports: [NzIconModule, NzOutletModule, NzSegmentedItemComponent]
                }]
        }], ctorParameters: () => [], propDecorators: { nzBlock: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], nzDisabled: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], nzOptions: [{
                type: Input
            }], nzVertical: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], nzShape: [{
                type: Input
            }], nzSize: [{
                type: Input
            }], nzName: [{
                type: Input
            }], nzValueChange: [{
                type: Output
            }], viewItemCmps: [{ type: i0.ViewChildren, args: [i0.forwardRef(() => NzSegmentedItemComponent), { isSignal: true }] }], contentItemCmps: [{ type: i0.ContentChildren, args: [i0.forwardRef(() => NzSegmentedItemComponent), { isSignal: true }] }] } });

/**
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE
 */
class NzSegmentedModule {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "21.0.0", ngImport: i0, type: NzSegmentedModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "21.0.0", ngImport: i0, type: NzSegmentedModule, imports: [NzSegmentedComponent, NzSegmentedItemComponent], exports: [NzSegmentedComponent, NzSegmentedItemComponent] });
    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "21.0.0", ngImport: i0, type: NzSegmentedModule, imports: [NzSegmentedComponent, NzSegmentedItemComponent] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "21.0.0", ngImport: i0, type: NzSegmentedModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [NzSegmentedComponent, NzSegmentedItemComponent],
                    exports: [NzSegmentedComponent, NzSegmentedItemComponent]
                }]
        }] });

/**
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE
 */

/**
 * Generated bundle index. Do not edit.
 */

export { NzSegmentedComponent, NzSegmentedItemComponent, NzSegmentedModule, normalizeOptions };
//# sourceMappingURL=ng-zorro-antd-segmented.mjs.map
