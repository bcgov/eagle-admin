import { __esDecorate, __runInitializers } from 'tslib';
import { ESCAPE, hasModifierKey } from '@angular/cdk/keycodes';
import { createFlexibleConnectedPositionStrategy, createOverlayRef, createRepositionScrollStrategy, ConnectionPositionPair, createCloseScrollStrategy } from '@angular/cdk/overlay';
import { Platform } from '@angular/cdk/platform';
import { TemplatePortal } from '@angular/cdk/portal';
import * as i0 from '@angular/core';
import { inject, Renderer2, ViewContainerRef, DestroyRef, ElementRef, Injector, EventEmitter, booleanAttribute, Output, Input, Directive, NgModule, ChangeDetectorRef, TemplateRef, ViewChild, ChangeDetectionStrategy, ViewEncapsulation, Component, NgZone, Injectable } from '@angular/core';
import { takeUntilDestroyed } from '@angular/core/rxjs-interop';
import { BehaviorSubject, Subject, merge, fromEvent, EMPTY, combineLatest, Subscription } from 'rxjs';
import { map, switchMap, filter, auditTime, distinctUntilChanged, first } from 'rxjs/operators';
import { WithConfig, NzConfigService } from 'ng-zorro-antd/core/config';
import { getPlacementName, setConnectedPositionOffset, POSITION_MAP, TOOLTIP_OFFSET_MAP } from 'ng-zorro-antd/core/overlay';
import { MenuService, NzIsMenuInsideDropdownToken, NzMenuModule } from 'ng-zorro-antd/menu';
import { Directionality } from '@angular/cdk/bidi';
import { NzNoAnimationDirective, slideAnimationEnter, slideAnimationLeave } from 'ng-zorro-antd/core/animation';
import { fromEventOutsideAngular } from 'ng-zorro-antd/core/util';

const NZ_CONFIG_MODULE_NAME = 'dropdown';
const listOfPositions = ['bottomLeft', 'bottomRight', 'topRight', 'topLeft'];
const normalizePlacementForClass = (p) => {
    // Map center placements to generic top/bottom classes for styling
    if (p === 'topCenter') {
        return 'top';
    }
    if (p === 'bottomCenter') {
        return 'bottom';
    }
    return p;
};
let NzDropdownDirective = (() => {
    let _nzBackdrop_decorators;
    let _nzBackdrop_initializers = [];
    let _nzBackdrop_extraInitializers = [];
    return class NzDropdownDirective {
        static {
            const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(null) : void 0;
            _nzBackdrop_decorators = [WithConfig()];
            __esDecorate(null, null, _nzBackdrop_decorators, { kind: "field", name: "nzBackdrop", static: false, private: false, access: { has: obj => "nzBackdrop" in obj, get: obj => obj.nzBackdrop, set: (obj, value) => { obj.nzBackdrop = value; } }, metadata: _metadata }, _nzBackdrop_initializers, _nzBackdrop_extraInitializers);
            if (_metadata) Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
        }
        nzConfigService = inject(NzConfigService);
        renderer = inject(Renderer2);
        viewContainerRef = inject(ViewContainerRef);
        platform = inject(Platform);
        destroyRef = inject(DestroyRef);
        _nzModuleName = NZ_CONFIG_MODULE_NAME;
        elementRef = inject(ElementRef);
        injector = inject(Injector);
        portal;
        overlayRef = null;
        inputVisible$ = new BehaviorSubject(false);
        nzTrigger$ = new BehaviorSubject('hover');
        overlayClose$ = new Subject();
        nzDropdownMenu = null;
        nzTrigger = 'hover';
        nzMatchWidthElement = null;
        nzBackdrop = __runInitializers(this, _nzBackdrop_initializers, false);
        nzClickHide = (__runInitializers(this, _nzBackdrop_extraInitializers), true);
        nzDisabled = false;
        nzVisible = false;
        nzArrow = false;
        nzOverlayClassName = '';
        nzOverlayStyle = {};
        nzPlacement = 'bottomLeft';
        nzVisibleChange = new EventEmitter();
        constructor() {
            this.destroyRef.onDestroy(() => {
                this.overlayRef?.dispose();
                this.overlayRef = null;
            });
        }
        setDropdownMenuValue(key, value) {
            this.nzDropdownMenu?.setValue(key, value);
        }
        ngAfterViewInit() {
            if (this.nzDropdownMenu) {
                const nativeElement = this.elementRef.nativeElement;
                /** host mouse state **/
                const hostMouseState$ = merge(fromEvent(nativeElement, 'mouseenter').pipe(map(() => true)), fromEvent(nativeElement, 'mouseleave').pipe(map(() => false)));
                /** menu mouse state **/
                const menuMouseState$ = this.nzDropdownMenu.mouseState$;
                /** merged mouse state **/
                const mergedMouseState$ = merge(menuMouseState$, hostMouseState$);
                /** host click state **/
                const hostClickState$ = fromEvent(nativeElement, 'click').pipe(map(() => !this.nzVisible));
                /** visible state switch by nzTrigger **/
                const visibleStateByTrigger$ = this.nzTrigger$.pipe(switchMap(trigger => {
                    if (trigger === 'hover') {
                        return mergedMouseState$;
                    }
                    else if (trigger === 'click') {
                        return hostClickState$;
                    }
                    else {
                        return EMPTY;
                    }
                }));
                const descendantMenuItemClick$ = this.nzDropdownMenu.descendantMenuItemClick$.pipe(filter(() => this.nzClickHide), map(() => false));
                const domTriggerVisible$ = merge(visibleStateByTrigger$, descendantMenuItemClick$, this.overlayClose$).pipe(filter(() => !this.nzDisabled));
                const visible$ = merge(this.inputVisible$, domTriggerVisible$);
                combineLatest([visible$, this.nzDropdownMenu.isChildSubMenuOpen$])
                    .pipe(map(([visible, sub]) => visible || sub), auditTime(150), distinctUntilChanged(), filter(() => this.platform.isBrowser), takeUntilDestroyed(this.destroyRef))
                    .subscribe(visible => {
                    const element = this.nzMatchWidthElement ? this.nzMatchWidthElement.nativeElement : nativeElement;
                    const triggerWidth = element.getBoundingClientRect().width;
                    if (this.nzVisible !== visible) {
                        this.nzVisibleChange.emit(visible);
                    }
                    this.nzVisible = visible;
                    if (visible) {
                        const positionStrategy = createFlexibleConnectedPositionStrategy(this.injector, this.elementRef.nativeElement)
                            .withLockedPosition()
                            .withTransformOriginOn('.ant-dropdown');
                        // Listen for placement changes to update the menu classes (arrow position)
                        positionStrategy.positionChanges
                            .pipe(filter(() => Boolean(this.overlayRef)), map(change => getPlacementName(change)), takeUntilDestroyed(this.destroyRef))
                            .subscribe(placement => {
                            if (placement) {
                                this.setDropdownMenuValue('placement', normalizePlacementForClass(placement));
                            }
                        });
                        /** set up overlayRef **/
                        if (!this.overlayRef) {
                            /** new overlay **/
                            this.overlayRef = createOverlayRef(this.injector, {
                                positionStrategy,
                                minWidth: triggerWidth,
                                disposeOnNavigation: true,
                                hasBackdrop: this.nzBackdrop && this.nzTrigger === 'click',
                                scrollStrategy: createRepositionScrollStrategy(this.injector)
                            });
                            merge(this.overlayRef.backdropClick(), this.overlayRef.detachments(), this.overlayRef
                                .outsidePointerEvents()
                                .pipe(filter(e => !this.elementRef.nativeElement.contains(e.target))), this.overlayRef.keydownEvents().pipe(filter(e => e.keyCode === ESCAPE && !hasModifierKey(e))))
                                .pipe(takeUntilDestroyed(this.destroyRef))
                                .subscribe(() => {
                                this.overlayClose$.next(false);
                            });
                        }
                        else {
                            /** update overlay config **/
                            const overlayConfig = this.overlayRef.getConfig();
                            overlayConfig.minWidth = triggerWidth;
                        }
                        /** open dropdown with animation **/
                        const positions = [this.nzPlacement, ...listOfPositions].map(position => {
                            return this.nzArrow
                                ? setConnectedPositionOffset(POSITION_MAP[position], TOOLTIP_OFFSET_MAP[position])
                                : POSITION_MAP[position];
                        });
                        positionStrategy.withPositions(positions);
                        /** reset portal if needed **/
                        if (!this.portal || this.portal.templateRef !== this.nzDropdownMenu.templateRef) {
                            this.portal = new TemplatePortal(this.nzDropdownMenu.templateRef, this.viewContainerRef);
                        }
                        // Initialize arrow and placement on open
                        this.setDropdownMenuValue('nzArrow', this.nzArrow);
                        this.setDropdownMenuValue('placement', normalizePlacementForClass(this.nzPlacement));
                        this.overlayRef.attach(this.portal);
                    }
                    else {
                        /** detach overlayRef if needed **/
                        this.overlayRef?.detach();
                    }
                });
                this.nzDropdownMenu.animationStateChange$.pipe(takeUntilDestroyed(this.destroyRef)).subscribe((event) => {
                    this.overlayRef?.dispose();
                    this.overlayRef = null;
                    event.animationComplete();
                });
            }
        }
        ngOnChanges(changes) {
            const { nzVisible, nzDisabled, nzOverlayClassName, nzOverlayStyle, nzTrigger, nzArrow, nzPlacement } = changes;
            if (nzTrigger) {
                this.nzTrigger$.next(this.nzTrigger);
            }
            if (nzVisible) {
                this.inputVisible$.next(this.nzVisible);
            }
            if (nzDisabled) {
                const nativeElement = this.elementRef.nativeElement;
                if (this.nzDisabled) {
                    this.renderer.setAttribute(nativeElement, 'disabled', '');
                    this.inputVisible$.next(false);
                }
                else {
                    this.renderer.removeAttribute(nativeElement, 'disabled');
                }
            }
            if (nzOverlayClassName) {
                this.setDropdownMenuValue('nzOverlayClassName', this.nzOverlayClassName);
            }
            if (nzOverlayStyle) {
                this.setDropdownMenuValue('nzOverlayStyle', this.nzOverlayStyle);
            }
            if (nzArrow) {
                this.setDropdownMenuValue('nzArrow', this.nzArrow);
            }
            if (nzPlacement) {
                this.setDropdownMenuValue('placement', normalizePlacementForClass(this.nzPlacement));
            }
        }
        static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "21.0.0", ngImport: i0, type: NzDropdownDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
        static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "16.1.0", version: "21.0.0", type: NzDropdownDirective, isStandalone: true, selector: "[nz-dropdown]", inputs: { nzDropdownMenu: "nzDropdownMenu", nzTrigger: "nzTrigger", nzMatchWidthElement: "nzMatchWidthElement", nzBackdrop: ["nzBackdrop", "nzBackdrop", booleanAttribute], nzClickHide: ["nzClickHide", "nzClickHide", booleanAttribute], nzDisabled: ["nzDisabled", "nzDisabled", booleanAttribute], nzVisible: ["nzVisible", "nzVisible", booleanAttribute], nzArrow: ["nzArrow", "nzArrow", booleanAttribute], nzOverlayClassName: "nzOverlayClassName", nzOverlayStyle: "nzOverlayStyle", nzPlacement: "nzPlacement" }, outputs: { nzVisibleChange: "nzVisibleChange" }, host: { classAttribute: "ant-dropdown-trigger" }, exportAs: ["nzDropdown"], usesOnChanges: true, ngImport: i0 });
    };
})();
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "21.0.0", ngImport: i0, type: NzDropdownDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[nz-dropdown]',
                    exportAs: 'nzDropdown',
                    host: {
                        class: 'ant-dropdown-trigger'
                    }
                }]
        }], ctorParameters: () => [], propDecorators: { nzDropdownMenu: [{
                type: Input
            }], nzTrigger: [{
                type: Input
            }], nzMatchWidthElement: [{
                type: Input
            }], nzBackdrop: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], nzClickHide: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], nzDisabled: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], nzVisible: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], nzArrow: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], nzOverlayClassName: [{
                type: Input
            }], nzOverlayStyle: [{
                type: Input
            }], nzPlacement: [{
                type: Input
            }], nzVisibleChange: [{
                type: Output
            }] } });

/**
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE
 */
class NzContextMenuServiceModule {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "21.0.0", ngImport: i0, type: NzContextMenuServiceModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "21.0.0", ngImport: i0, type: NzContextMenuServiceModule });
    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "21.0.0", ngImport: i0, type: NzContextMenuServiceModule });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "21.0.0", ngImport: i0, type: NzContextMenuServiceModule, decorators: [{
            type: NgModule
        }] });

/**
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE
 */
class NzDropdownADirective {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "21.0.0", ngImport: i0, type: NzDropdownADirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "21.0.0", type: NzDropdownADirective, isStandalone: true, selector: "a[nz-dropdown]", host: { classAttribute: "ant-dropdown-link" }, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "21.0.0", ngImport: i0, type: NzDropdownADirective, decorators: [{
            type: Directive,
            args: [{
                    selector: 'a[nz-dropdown]',
                    host: {
                        class: 'ant-dropdown-link'
                    }
                }]
        }] });

/**
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE
 */
class NzDropdownMenuComponent {
    cdr = inject(ChangeDetectorRef);
    elementRef = inject(ElementRef);
    renderer = inject(Renderer2);
    viewContainerRef = inject(ViewContainerRef);
    directionality = inject(Directionality);
    destroyRef = inject(DestroyRef);
    noAnimation = inject(NzNoAnimationDirective, { host: true, optional: true });
    nzMenuService = inject(MenuService);
    isChildSubMenuOpen$ = this.nzMenuService.isChildSubMenuOpen$;
    descendantMenuItemClick$ = this.nzMenuService.descendantMenuItemClick$;
    mouseState$ = new BehaviorSubject(false);
    animationStateChange$ = new EventEmitter();
    templateRef;
    nzOverlayClassName = '';
    nzOverlayStyle = {};
    nzArrow = false;
    placement = 'bottomLeft';
    dir = 'ltr';
    dropdownAnimationEnter = slideAnimationEnter();
    dropdownAnimationLeave = slideAnimationLeave();
    onAnimationEvent(event) {
        const element = event.target;
        const onAnimationEnd = () => {
            element.removeEventListener('animationend', onAnimationEnd);
            this.animationStateChange$.emit(event);
        };
        element.addEventListener('animationend', onAnimationEnd);
    }
    setMouseState(visible) {
        this.mouseState$.next(visible);
    }
    setValue(key, value) {
        this[key] = value;
        this.cdr.markForCheck();
    }
    ngOnInit() {
        this.directionality.change?.pipe(takeUntilDestroyed(this.destroyRef)).subscribe(direction => {
            this.dir = direction;
            this.cdr.detectChanges();
        });
        this.dir = this.directionality.value;
    }
    ngAfterContentInit() {
        this.renderer.removeChild(this.renderer.parentNode(this.elementRef.nativeElement), this.elementRef.nativeElement);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "21.0.0", ngImport: i0, type: NzDropdownMenuComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "21.0.0", type: NzDropdownMenuComponent, isStandalone: true, selector: "nz-dropdown-menu", providers: [
            MenuService,
            /** menu is inside dropdown-menu component **/
            {
                provide: NzIsMenuInsideDropdownToken,
                useValue: true
            }
        ], viewQueries: [{ propertyName: "templateRef", first: true, predicate: TemplateRef, descendants: true, static: true }], exportAs: ["nzDropdownMenu"], ngImport: i0, template: `
    <ng-template>
      <div
        class="ant-dropdown"
        [class.ant-dropdown-rtl]="dir === 'rtl'"
        [class.ant-dropdown-show-arrow]="nzArrow"
        [class.ant-dropdown-placement-bottomLeft]="placement === 'bottomLeft'"
        [class.ant-dropdown-placement-bottomRight]="placement === 'bottomRight'"
        [class.ant-dropdown-placement-bottom]="placement === 'bottom'"
        [class.ant-dropdown-placement-topLeft]="placement === 'topLeft'"
        [class.ant-dropdown-placement-topRight]="placement === 'topRight'"
        [class.ant-dropdown-placement-top]="placement === 'top'"
        [class]="nzOverlayClassName"
        [style]="nzOverlayStyle"
        [animate.enter]="dropdownAnimationEnter()"
        [animate.leave]="dropdownAnimationLeave()"
        (animate.leave)="onAnimationEvent($event)"
        [nzNoAnimation]="!!noAnimation?.nzNoAnimation?.()"
        (mouseenter)="setMouseState(true)"
        (mouseleave)="setMouseState(false)"
      >
        @if (nzArrow) {
          <div class="ant-dropdown-arrow"></div>
        }
        <ng-content></ng-content>
      </div>
    </ng-template>
  `, isInline: true, dependencies: [{ kind: "directive", type: NzNoAnimationDirective, selector: "[nzNoAnimation]", inputs: ["nzNoAnimation"], exportAs: ["nzNoAnimation"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush, encapsulation: i0.ViewEncapsulation.None });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "21.0.0", ngImport: i0, type: NzDropdownMenuComponent, decorators: [{
            type: Component,
            args: [{
                    selector: `nz-dropdown-menu`,
                    exportAs: `nzDropdownMenu`,
                    providers: [
                        MenuService,
                        /** menu is inside dropdown-menu component **/
                        {
                            provide: NzIsMenuInsideDropdownToken,
                            useValue: true
                        }
                    ],
                    template: `
    <ng-template>
      <div
        class="ant-dropdown"
        [class.ant-dropdown-rtl]="dir === 'rtl'"
        [class.ant-dropdown-show-arrow]="nzArrow"
        [class.ant-dropdown-placement-bottomLeft]="placement === 'bottomLeft'"
        [class.ant-dropdown-placement-bottomRight]="placement === 'bottomRight'"
        [class.ant-dropdown-placement-bottom]="placement === 'bottom'"
        [class.ant-dropdown-placement-topLeft]="placement === 'topLeft'"
        [class.ant-dropdown-placement-topRight]="placement === 'topRight'"
        [class.ant-dropdown-placement-top]="placement === 'top'"
        [class]="nzOverlayClassName"
        [style]="nzOverlayStyle"
        [animate.enter]="dropdownAnimationEnter()"
        [animate.leave]="dropdownAnimationLeave()"
        (animate.leave)="onAnimationEvent($event)"
        [nzNoAnimation]="!!noAnimation?.nzNoAnimation?.()"
        (mouseenter)="setMouseState(true)"
        (mouseleave)="setMouseState(false)"
      >
        @if (nzArrow) {
          <div class="ant-dropdown-arrow"></div>
        }
        <ng-content></ng-content>
      </div>
    </ng-template>
  `,
                    encapsulation: ViewEncapsulation.None,
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    imports: [NzNoAnimationDirective]
                }]
        }], propDecorators: { templateRef: [{
                type: ViewChild,
                args: [TemplateRef, { static: true }]
            }] } });

/**
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE
 */
class NzDropdownModule {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "21.0.0", ngImport: i0, type: NzDropdownModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "21.0.0", ngImport: i0, type: NzDropdownModule, imports: [NzDropdownDirective, NzDropdownADirective, NzDropdownMenuComponent, NzContextMenuServiceModule], exports: [NzMenuModule, NzDropdownDirective, NzDropdownADirective, NzDropdownMenuComponent] });
    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "21.0.0", ngImport: i0, type: NzDropdownModule, imports: [NzContextMenuServiceModule, NzMenuModule] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "21.0.0", ngImport: i0, type: NzDropdownModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [NzDropdownDirective, NzDropdownADirective, NzDropdownMenuComponent, NzContextMenuServiceModule],
                    exports: [NzMenuModule, NzDropdownDirective, NzDropdownADirective, NzDropdownMenuComponent]
                }]
        }] });
/**
 * @deprecated Use {@link NzDropdownModule} instead.
 * This will be removed in v22.0.0.
 */
const NzDropDownModule = NzDropdownModule;

/**
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE
 */
const LIST_OF_POSITIONS = [
    new ConnectionPositionPair({ originX: 'start', originY: 'top' }, { overlayX: 'start', overlayY: 'top' }),
    new ConnectionPositionPair({ originX: 'start', originY: 'top' }, { overlayX: 'start', overlayY: 'bottom' }),
    new ConnectionPositionPair({ originX: 'start', originY: 'top' }, { overlayX: 'end', overlayY: 'bottom' }),
    new ConnectionPositionPair({ originX: 'start', originY: 'top' }, { overlayX: 'end', overlayY: 'top' })
];
class NzContextMenuService {
    ngZone = inject(NgZone);
    injector = inject(Injector);
    overlayRef = null;
    closeSubscription = Subscription.EMPTY;
    create($event, nzDropdownMenuComponent) {
        this.close(true);
        const { x, y } = $event;
        if ($event instanceof MouseEvent) {
            $event.preventDefault();
        }
        this.overlayRef = createOverlayRef(this.injector, {
            positionStrategy: createFlexibleConnectedPositionStrategy(this.injector, { x, y })
                .withPositions(LIST_OF_POSITIONS)
                .withTransformOriginOn('.ant-dropdown'),
            disposeOnNavigation: true,
            scrollStrategy: createCloseScrollStrategy(this.injector)
        });
        this.closeSubscription = new Subscription();
        this.closeSubscription.add(nzDropdownMenuComponent.descendantMenuItemClick$.subscribe(() => this.close()));
        this.closeSubscription.add(merge(fromEventOutsideAngular(document, 'click').pipe(filter(event => !!this.overlayRef && !this.overlayRef.overlayElement.contains(event.target)), 
        /** handle firefox contextmenu event **/
        filter(event => event.button !== 2)), fromEventOutsideAngular(document, 'keydown').pipe(filter(event => event.key === 'Escape')))
            .pipe(first())
            .subscribe(() => this.ngZone.run(() => this.close())));
        return this.overlayRef.attach(new TemplatePortal(nzDropdownMenuComponent.templateRef, nzDropdownMenuComponent.viewContainerRef));
    }
    close(clear = false) {
        if (this.overlayRef) {
            this.overlayRef.detach();
            if (clear) {
                this.overlayRef.dispose();
            }
            this.overlayRef = null;
            this.closeSubscription.unsubscribe();
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "21.0.0", ngImport: i0, type: NzContextMenuService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "21.0.0", ngImport: i0, type: NzContextMenuService, providedIn: NzContextMenuServiceModule });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "21.0.0", ngImport: i0, type: NzContextMenuService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: NzContextMenuServiceModule
                }]
        }] });

/**
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE
 */

/**
 * Generated bundle index. Do not edit.
 */

export { NzContextMenuService, NzContextMenuServiceModule, NzDropDownModule, NzDropdownADirective, NzDropdownDirective, NzDropdownMenuComponent, NzDropdownModule };
//# sourceMappingURL=ng-zorro-antd-dropdown.mjs.map
