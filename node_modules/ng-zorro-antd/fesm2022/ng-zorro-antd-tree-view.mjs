import * as i0 from '@angular/core';
import { input, booleanAttribute, output, inject, ChangeDetectorRef, DestroyRef, ElementRef, NgZone, ChangeDetectionStrategy, Component, Input, Directive, forwardRef, signal, ViewContainerRef, effect, numberAttribute, ViewChild, ViewEncapsulation, NgModule } from '@angular/core';
import { takeUntilDestroyed } from '@angular/core/rxjs-interop';
import { filter, auditTime, take, map } from 'rxjs/operators';
import { fromEventOutsideAngular } from 'ng-zorro-antd/core/util';
import { Subject, animationFrameScheduler, asapScheduler, merge, BehaviorSubject } from 'rxjs';
import { CdkTreeNode, CdkTree, CdkTreeNodeToggle, CdkTreeNodeDef, CdkTreeNodeOutlet, CdkTreeNodePadding, CdkTreeNodeOutletContext } from '@angular/cdk/tree';
import { Directionality } from '@angular/cdk/bidi';
import * as i1 from 'ng-zorro-antd/core/animation';
import { NzNoAnimationDirective, NzAnimationTreeCollapseDirective, NzAnimationTreeCollapseService } from 'ng-zorro-antd/core/animation';
import { CdkFixedSizeVirtualScroll, CdkVirtualForOf, CdkVirtualScrollViewport } from '@angular/cdk/scrolling';
import { DataSource } from '@angular/cdk/collections';

/**
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE
 */
class NzTreeNodeCheckboxComponent {
    nzChecked = input(false, ...(ngDevMode ? [{ debugName: "nzChecked", transform: booleanAttribute }] : [{ transform: booleanAttribute }]));
    nzIndeterminate = input(false, ...(ngDevMode ? [{ debugName: "nzIndeterminate", transform: booleanAttribute }] : [{ transform: booleanAttribute }]));
    nzDisabled = input(false, ...(ngDevMode ? [{ debugName: "nzDisabled", transform: booleanAttribute }] : [{ transform: booleanAttribute }]));
    nzClick = output();
    cdr = inject(ChangeDetectorRef);
    destroyRef = inject(DestroyRef);
    elementRef = inject(ElementRef);
    ngZone = inject(NgZone);
    ngOnInit() {
        fromEventOutsideAngular(this.elementRef.nativeElement, 'click')
            .pipe(filter(() => !this.nzDisabled()), takeUntilDestroyed(this.destroyRef))
            .subscribe((event) => {
            this.ngZone.run(() => {
                this.nzClick.emit(event);
            });
        });
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "21.0.0", ngImport: i0, type: NzTreeNodeCheckboxComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.1.0", version: "21.0.0", type: NzTreeNodeCheckboxComponent, isStandalone: true, selector: "nz-tree-node-checkbox:not([builtin])", inputs: { nzChecked: { classPropertyName: "nzChecked", publicName: "nzChecked", isSignal: true, isRequired: false, transformFunction: null }, nzIndeterminate: { classPropertyName: "nzIndeterminate", publicName: "nzIndeterminate", isSignal: true, isRequired: false, transformFunction: null }, nzDisabled: { classPropertyName: "nzDisabled", publicName: "nzDisabled", isSignal: true, isRequired: false, transformFunction: null } }, outputs: { nzClick: "nzClick" }, host: { properties: { "class.ant-tree-checkbox-checked": "nzChecked()", "class.ant-tree-checkbox-indeterminate": "nzIndeterminate()", "class.ant-tree-checkbox-disabled": "nzDisabled()" }, classAttribute: "ant-tree-checkbox" }, ngImport: i0, template: `<span class="ant-tree-checkbox-inner"></span>`, isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "21.0.0", ngImport: i0, type: NzTreeNodeCheckboxComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'nz-tree-node-checkbox:not([builtin])',
                    template: `<span class="ant-tree-checkbox-inner"></span>`,
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    host: {
                        class: 'ant-tree-checkbox',
                        '[class.ant-tree-checkbox-checked]': `nzChecked()`,
                        '[class.ant-tree-checkbox-indeterminate]': `nzIndeterminate()`,
                        '[class.ant-tree-checkbox-disabled]': `nzDisabled()`
                    }
                }]
        }], propDecorators: { nzChecked: [{ type: i0.Input, args: [{ isSignal: true, alias: "nzChecked", required: false }] }], nzIndeterminate: [{ type: i0.Input, args: [{ isSignal: true, alias: "nzIndeterminate", required: false }] }], nzDisabled: [{ type: i0.Input, args: [{ isSignal: true, alias: "nzDisabled", required: false }] }], nzClick: [{ type: i0.Output, args: ["nzClick"] }] } });

/**
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE
 */
class NzNodeBase extends CdkTreeNode {
}

/**
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE
 */
const getParent = (nodes, node, getLevel) => {
    let index = nodes.indexOf(node);
    if (index < 0) {
        return null;
    }
    const level = getLevel(node);
    for (index--; index >= 0; index--) {
        const preLevel = getLevel(nodes[index]);
        if (preLevel + 1 === level) {
            return nodes[index];
        }
        if (preLevel + 1 < level) {
            return null;
        }
    }
    return null;
};
const getDescendants = (nodes, node, getLevel) => {
    let index = nodes.indexOf(node);
    if (index < 0) {
        return [];
    }
    const result = [];
    const level = getLevel(nodes[index]);
    for (index++; index < nodes.length; index++) {
        if (getLevel(nodes[index]) > level) {
            result.push(nodes[index]);
        }
        else {
            break;
        }
    }
    return result;
};
const getNextSibling = (nodes, node, getLevel, _index) => {
    let index = typeof _index !== 'undefined' ? _index : nodes.indexOf(node);
    if (index < 0) {
        return null;
    }
    const level = getLevel(node);
    for (index++; index < nodes.length; index++) {
        const nextLevel = getLevel(nodes[index]);
        if (nextLevel < level) {
            return null;
        }
        if (nextLevel === level) {
            return nodes[index];
        }
    }
    return null;
};
const getParentForNestedData = (nodes, node, getChildren) => {
    for (const parent of flattenNestedNodes(nodes, getChildren)) {
        if (getChildren(parent)?.includes(node)) {
            return parent;
        }
    }
    return null;
};
const getNextSiblingForNestedData = (nodes, node, getChildren) => {
    const len = nodes.length;
    for (let i = 0; i < len; i++) {
        if (nodes[i] === node) {
            return i + 1 < len ? nodes[i + 1] : null;
        }
        const children = getChildren(nodes[i]);
        if (children && children.length > 0) {
            const sibling = getNextSiblingForNestedData(children, node, getChildren);
            if (sibling) {
                return sibling;
            }
        }
    }
    return null;
};
const getDescendantsForNestedData = (node, getChildren) => {
    let result = [];
    const children = getChildren(node);
    if (children && children.length > 0) {
        children.forEach(child => {
            result.push(child);
            result = result.concat(getDescendantsForNestedData(child, getChildren));
        });
    }
    return result;
};
const flattenNestedNodes = (nodes, getChildren) => {
    const flattenedNodes = [];
    for (const node of nodes) {
        flattenedNodes.push(node);
        if (getChildren(node)) {
            flattenedNodes.push(...flattenNestedNodes(getChildren(node), getChildren));
        }
    }
    return flattenedNodes;
};

/**
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE
 */
class NzTreeView extends CdkTree {
    /* eslint-disable @angular-eslint/no-input-rename */
    levelAccessor = undefined;
    childrenAccessor = undefined;
    get dataSource() {
        return super.dataSource;
    }
    set dataSource(dataSource) {
        super.dataSource = dataSource;
    }
    trackBy = (_index, item) => item;
    nzDirectoryTree = false;
    nzBlockNode = false;
    noAnimation = inject(NzNoAnimationDirective, { host: true, optional: true });
    destroyRef = inject(DestroyRef);
    directionality = inject(Directionality);
    cdr = inject(ChangeDetectorRef);
    dir = inject(Directionality).valueSignal;
    dataSourceChanged$ = new Subject();
    dataNodes = [];
    renderNodeChanges(data, dataDiffer, viewContainer, parentData) {
        /* https://github.com/angular/components/blob/21cc21ea3b280c3f82a19f5ec1b679eb1eee1358/src/cdk/tree/tree.ts#L1103
         * If levelAccessor is used, renderNodes needs to be recalculated, because flattenData (i.e., dataNodes) is used as renderNodes by default in the @angular/components library
         * If childrenAccessor is used, @angular/cdk library inner will calculate renderNodes.
         */
        const renderNodes = this.levelAccessor ? this.getRenderNodes(data) : [...data];
        super.renderNodeChanges(renderNodes, dataDiffer, viewContainer, parentData);
        this.dataSourceChanged$.next();
        this.cdr.markForCheck();
    }
    /**
     * get render nodes (length <= flattenData.length)>
     * @param nodes all flatten nodes
     */
    getRenderNodes(nodes) {
        const getLevel = this.levelAccessor;
        const results = [];
        const currentExpand = [];
        currentExpand[0] = true;
        nodes.forEach(node => {
            let expand = true;
            for (let i = 0; i <= getLevel(node); i++) {
                expand = expand && currentExpand[i];
            }
            if (expand) {
                results.push(node);
            }
            if (getDescendants(nodes, node, getLevel)) {
                currentExpand[getLevel(node) + 1] = this.isExpanded(node);
            }
        });
        return results;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "21.0.0", ngImport: i0, type: NzTreeView, deps: null, target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "16.1.0", version: "21.0.0", type: NzTreeView, isStandalone: true, selector: "ng-component", inputs: { levelAccessor: ["nzLevelAccessor", "levelAccessor"], childrenAccessor: ["nzChildrenAccessor", "childrenAccessor"], dataSource: ["nzDataSource", "dataSource"], trackBy: ["nzTrackBy", "trackBy"], nzDirectoryTree: ["nzDirectoryTree", "nzDirectoryTree", booleanAttribute], nzBlockNode: ["nzBlockNode", "nzBlockNode", booleanAttribute] }, usesInheritance: true, ngImport: i0, template: '', isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "21.0.0", ngImport: i0, type: NzTreeView, decorators: [{
            type: Component,
            args: [{
                    template: ''
                }]
        }], propDecorators: { levelAccessor: [{
                type: Input,
                args: [{ alias: 'nzLevelAccessor' }]
            }], childrenAccessor: [{
                type: Input,
                args: [{ alias: 'nzChildrenAccessor' }]
            }], dataSource: [{
                type: Input,
                args: [{ alias: 'nzDataSource' }]
            }], trackBy: [{
                type: Input,
                args: [{ alias: 'nzTrackBy' }]
            }], nzDirectoryTree: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], nzBlockNode: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }] } });

/**
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE
 */
/**
 * [true, false, false, true] => 1001
 */
function booleanArrayToString(arr) {
    return arr.map(i => (i ? 1 : 0)).join('');
}
const BUILD_INDENTS_SCHEDULER = typeof requestAnimationFrame !== 'undefined' ? animationFrameScheduler : asapScheduler;
class NzTreeNodeIndentsComponent {
    indents = [];
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "21.0.0", ngImport: i0, type: NzTreeNodeIndentsComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "21.0.0", type: NzTreeNodeIndentsComponent, isStandalone: true, selector: "nz-tree-node-indents", inputs: { indents: "indents" }, host: { classAttribute: "ant-tree-indent" }, ngImport: i0, template: `
    @for (isEnd of indents; track isEnd) {
      <span class="ant-tree-indent-unit" [class.ant-tree-indent-unit-end]="!isEnd"></span>
    }
  `, isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "21.0.0", ngImport: i0, type: NzTreeNodeIndentsComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'nz-tree-node-indents',
                    template: `
    @for (isEnd of indents; track isEnd) {
      <span class="ant-tree-indent-unit" [class.ant-tree-indent-unit-end]="!isEnd"></span>
    }
  `,
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    host: {
                        class: 'ant-tree-indent'
                    }
                }]
        }], propDecorators: { indents: [{
                type: Input
            }] } });
class NzTreeNodeIndentLineDirective {
    treeNode = inject((NzNodeBase));
    tree = inject((NzTreeView));
    cdr = inject(ChangeDetectorRef);
    destroyRef = inject(DestroyRef);
    preNodeRef = null;
    nextNodeRef = null;
    currentIndents = '';
    isLast = 'unset';
    get isLeaf() {
        return this.treeNode.isLeaf;
    }
    get dataNodes() {
        return this.tree.dataNodes;
    }
    get currentDataNode() {
        return this.treeNode.data;
    }
    constructor() {
        this.buildIndents();
        this.checkLast();
        /**
         * setting the indents can cause frame rate loss if it is set too often.
         */
        merge(this.treeNode._dataChanges, this.tree.dataSourceChanged$)
            .pipe(auditTime(0, BUILD_INDENTS_SCHEDULER), takeUntilDestroyed(this.destroyRef))
            .subscribe(() => {
            this.buildIndents();
            this.checkAdjacent();
            this.cdr.markForCheck();
        });
    }
    /**
     * The true and false in indents indicate whether there should be a vertical line to the left of the current node.
     * if there is no nextSibling, there is no vertical line.
     */
    getIndents() {
        if (this.tree.levelAccessor) {
            return this.getIndentsForFlatData(this.dataNodes, this.currentDataNode, this.tree.levelAccessor);
        }
        else if (this.tree.childrenAccessor) {
            return this.getIndentsForNestedData(this.dataNodes, this.currentDataNode, this.tree.childrenAccessor);
        }
        else {
            return [];
        }
    }
    getIndentsForFlatData(nodes, node, getLevel) {
        const indents = [];
        let parent = getParent(nodes, node, getLevel);
        while (parent) {
            const parentNextSibling = getNextSibling(nodes, parent, getLevel);
            if (parentNextSibling) {
                indents.unshift(true);
            }
            else {
                indents.unshift(false);
            }
            parent = getParent(nodes, parent, getLevel);
        }
        return indents;
    }
    getIndentsForNestedData(nodes, node, getChildren) {
        const indents = [];
        let parent = getParentForNestedData(nodes, node, getChildren);
        while (parent) {
            const parentNextSibling = getNextSiblingForNestedData(nodes, parent, getChildren);
            if (parentNextSibling) {
                indents.unshift(true);
            }
            else {
                indents.unshift(false);
            }
            parent = getParentForNestedData(nodes, parent, getChildren);
        }
        return indents;
    }
    buildIndents() {
        if (this.currentDataNode) {
            const indents = this.getIndents();
            const diffString = booleanArrayToString(indents);
            if (diffString !== this.currentIndents) {
                this.treeNode.setIndents(this.getIndents());
                this.currentIndents = diffString;
            }
        }
    }
    /**
     * We need to add a class name for the last child node,
     * this result can also be affected when the adjacent nodes are changed.
     */
    checkAdjacent() {
        let nodes = [];
        if (this.tree.levelAccessor) {
            nodes = this.dataNodes;
        }
        else if (this.tree.childrenAccessor) {
            nodes = flattenNestedNodes(this.dataNodes, this.tree.childrenAccessor);
        }
        this.checkAdjacentNodeChanged(nodes);
    }
    checkAdjacentNodeChanged(nodes) {
        const index = nodes.indexOf(this.currentDataNode);
        const preNode = nodes[index - 1] || null;
        const nextNode = nodes[index + 1] || null;
        if (this.nextNodeRef !== nextNode || this.preNodeRef !== preNode) {
            this.checkLast(index);
        }
        this.preNodeRef = preNode;
        this.nextNodeRef = nextNode;
    }
    checkLast(index) {
        if (this.tree.levelAccessor) {
            this.isLast = !getNextSibling(this.dataNodes, this.currentDataNode, this.tree.levelAccessor, index);
        }
        else if (this.tree.childrenAccessor) {
            this.isLast = !getNextSiblingForNestedData(this.dataNodes, this.currentDataNode, this.tree.childrenAccessor);
        }
        else {
            return;
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "21.0.0", ngImport: i0, type: NzTreeNodeIndentLineDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "21.0.0", type: NzTreeNodeIndentLineDirective, isStandalone: true, selector: "nz-tree-node[nzTreeNodeIndentLine]", host: { properties: { "class.ant-tree-treenode-leaf-last": "isLast && isLeaf" }, classAttribute: "ant-tree-show-line" }, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "21.0.0", ngImport: i0, type: NzTreeNodeIndentLineDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: 'nz-tree-node[nzTreeNodeIndentLine]',
                    host: {
                        class: 'ant-tree-show-line',
                        '[class.ant-tree-treenode-leaf-last]': 'isLast && isLeaf'
                    }
                }]
        }], ctorParameters: () => [] });

/**
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE
 */
class NzTreeNodeNoopToggleDirective {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "21.0.0", ngImport: i0, type: NzTreeNodeNoopToggleDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "21.0.0", type: NzTreeNodeNoopToggleDirective, isStandalone: true, selector: "nz-tree-node-toggle[nzTreeNodeNoopToggle], [nzTreeNodeNoopToggle]", host: { classAttribute: "ant-tree-switcher ant-tree-switcher-noop" }, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "21.0.0", ngImport: i0, type: NzTreeNodeNoopToggleDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: 'nz-tree-node-toggle[nzTreeNodeNoopToggle], [nzTreeNodeNoopToggle]',
                    host: {
                        class: 'ant-tree-switcher ant-tree-switcher-noop'
                    }
                }]
        }] });
class NzTreeNodeToggleDirective extends CdkTreeNodeToggle {
    recursive = false;
    get isExpanded() {
        return this._treeNode.isExpanded;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "21.0.0", ngImport: i0, type: NzTreeNodeToggleDirective, deps: null, target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "16.1.0", version: "21.0.0", type: NzTreeNodeToggleDirective, isStandalone: true, selector: "nz-tree-node-toggle:not([nzTreeNodeNoopToggle]), [nzTreeNodeToggle]", inputs: { recursive: ["nzTreeNodeToggleRecursive", "recursive", booleanAttribute] }, host: { properties: { "class.ant-tree-switcher_open": "isExpanded", "class.ant-tree-switcher_close": "!isExpanded" }, classAttribute: "ant-tree-switcher" }, providers: [{ provide: CdkTreeNodeToggle, useExisting: forwardRef(() => NzTreeNodeToggleDirective) }], usesInheritance: true, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "21.0.0", ngImport: i0, type: NzTreeNodeToggleDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: 'nz-tree-node-toggle:not([nzTreeNodeNoopToggle]), [nzTreeNodeToggle]',
                    providers: [{ provide: CdkTreeNodeToggle, useExisting: forwardRef(() => NzTreeNodeToggleDirective) }],
                    host: {
                        class: 'ant-tree-switcher',
                        '[class.ant-tree-switcher_open]': 'isExpanded',
                        '[class.ant-tree-switcher_close]': '!isExpanded'
                    }
                }]
        }], propDecorators: { recursive: [{
                type: Input,
                args: [{ alias: 'nzTreeNodeToggleRecursive', transform: booleanAttribute }]
            }] } });
class NzTreeNodeToggleRotateIconDirective {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "21.0.0", ngImport: i0, type: NzTreeNodeToggleRotateIconDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "21.0.0", type: NzTreeNodeToggleRotateIconDirective, isStandalone: true, selector: "[nzTreeNodeToggleRotateIcon]", host: { classAttribute: "ant-tree-switcher-icon" }, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "21.0.0", ngImport: i0, type: NzTreeNodeToggleRotateIconDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[nzTreeNodeToggleRotateIcon]',
                    host: {
                        class: 'ant-tree-switcher-icon'
                    }
                }]
        }] });
class NzTreeNodeToggleActiveIconDirective {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "21.0.0", ngImport: i0, type: NzTreeNodeToggleActiveIconDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "21.0.0", type: NzTreeNodeToggleActiveIconDirective, isStandalone: true, selector: "[nzTreeNodeToggleActiveIcon]", host: { classAttribute: "ant-tree-switcher-loading-icon" }, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "21.0.0", ngImport: i0, type: NzTreeNodeToggleActiveIconDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[nzTreeNodeToggleActiveIcon]',
                    host: {
                        class: 'ant-tree-switcher-loading-icon'
                    }
                }]
        }] });

/**
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE
 */
class NzTreeNodeComponent extends NzNodeBase {
    // Used to determine whether it is a leaf node
    get isExpandable() {
        return super.isExpandable;
    }
    set isExpandable(value) {
        super.isExpandable = value;
    }
    indents = signal([], ...(ngDevMode ? [{ debugName: "indents" }] : []));
    disabled = signal(false, ...(ngDevMode ? [{ debugName: "disabled" }] : []));
    selected = signal(false, ...(ngDevMode ? [{ debugName: "selected" }] : []));
    get isLeaf() {
        return !this.isExpandable;
    }
    disable() {
        this.disabled.set(true);
    }
    enable() {
        this.disabled.set(false);
    }
    select() {
        this.selected.set(true);
    }
    deselect() {
        this.selected.set(false);
    }
    setIndents(indents) {
        this.indents.set(indents);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "21.0.0", ngImport: i0, type: NzTreeNodeComponent, deps: null, target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "21.0.0", type: NzTreeNodeComponent, isStandalone: true, selector: "nz-tree-node:not([builtin])", inputs: { isExpandable: ["nzExpandable", "isExpandable", booleanAttribute] }, host: { properties: { "class.ant-tree-treenode-switcher-open": "isExpanded", "class.ant-tree-treenode-switcher-close": "!isExpanded", "class.ant-tree-treenode-selected": "selected()", "class.ant-tree-treenode-disabled": "disabled()" }, classAttribute: "ant-tree-treenode" }, providers: [
            {
                provide: CdkTreeNode,
                useExisting: forwardRef(() => NzTreeNodeComponent)
            },
            {
                provide: NzNodeBase,
                useExisting: forwardRef(() => NzTreeNodeComponent)
            }
        ], exportAs: ["nzTreeNode"], usesInheritance: true, hostDirectives: [{ directive: i1.NzAnimationTreeCollapseDirective }], ngImport: i0, template: `
    @if (indents().length) {
      <nz-tree-node-indents [indents]="indents()"></nz-tree-node-indents>
    }
    <ng-content select="nz-tree-node-toggle, [nz-tree-node-toggle]"></ng-content>
    @if (indents().length && isLeaf) {
      <nz-tree-node-toggle class="nz-tree-leaf-line-icon" nzTreeNodeNoopToggle>
        <span class="ant-tree-switcher-leaf-line"></span>
      </nz-tree-node-toggle>
    }
    <ng-content select="nz-tree-node-checkbox"></ng-content>
    <ng-content select="nz-tree-node-option"></ng-content>
    <ng-content></ng-content>
  `, isInline: true, dependencies: [{ kind: "component", type: NzTreeNodeIndentsComponent, selector: "nz-tree-node-indents", inputs: ["indents"] }, { kind: "directive", type: NzTreeNodeNoopToggleDirective, selector: "nz-tree-node-toggle[nzTreeNodeNoopToggle], [nzTreeNodeNoopToggle]" }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "21.0.0", ngImport: i0, type: NzTreeNodeComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'nz-tree-node:not([builtin])',
                    exportAs: 'nzTreeNode',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    providers: [
                        {
                            provide: CdkTreeNode,
                            useExisting: forwardRef(() => NzTreeNodeComponent)
                        },
                        {
                            provide: NzNodeBase,
                            useExisting: forwardRef(() => NzTreeNodeComponent)
                        }
                    ],
                    template: `
    @if (indents().length) {
      <nz-tree-node-indents [indents]="indents()"></nz-tree-node-indents>
    }
    <ng-content select="nz-tree-node-toggle, [nz-tree-node-toggle]"></ng-content>
    @if (indents().length && isLeaf) {
      <nz-tree-node-toggle class="nz-tree-leaf-line-icon" nzTreeNodeNoopToggle>
        <span class="ant-tree-switcher-leaf-line"></span>
      </nz-tree-node-toggle>
    }
    <ng-content select="nz-tree-node-checkbox"></ng-content>
    <ng-content select="nz-tree-node-option"></ng-content>
    <ng-content></ng-content>
  `,
                    hostDirectives: [NzAnimationTreeCollapseDirective],
                    host: {
                        class: 'ant-tree-treenode',
                        '[class.ant-tree-treenode-switcher-open]': 'isExpanded',
                        '[class.ant-tree-treenode-switcher-close]': '!isExpanded',
                        '[class.ant-tree-treenode-selected]': 'selected()',
                        '[class.ant-tree-treenode-disabled]': 'disabled()'
                    },
                    imports: [NzTreeNodeIndentsComponent, NzTreeNodeNoopToggleDirective]
                }]
        }], propDecorators: { isExpandable: [{
                type: Input,
                args: [{ alias: 'nzExpandable', transform: booleanAttribute }]
            }] } });
class NzTreeNodeDefDirective extends CdkTreeNodeDef {
    when = null;
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "21.0.0", ngImport: i0, type: NzTreeNodeDefDirective, deps: null, target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "21.0.0", type: NzTreeNodeDefDirective, isStandalone: true, selector: "[nzTreeNodeDef]", inputs: { when: ["nzTreeNodeDefWhen", "when"] }, providers: [
            {
                provide: CdkTreeNodeDef,
                useExisting: forwardRef(() => NzTreeNodeDefDirective)
            }
        ], usesInheritance: true, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "21.0.0", ngImport: i0, type: NzTreeNodeDefDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[nzTreeNodeDef]',
                    providers: [
                        {
                            provide: CdkTreeNodeDef,
                            useExisting: forwardRef(() => NzTreeNodeDefDirective)
                        }
                    ]
                }]
        }], propDecorators: { when: [{
                type: Input,
                args: [{ alias: 'nzTreeNodeDefWhen' }]
            }] } });
class NzTreeVirtualScrollNodeOutletDirective {
    data = input.required(...(ngDevMode ? [{ debugName: "data" }] : []));
    compareBy = input.required(...(ngDevMode ? [{ debugName: "compareBy" }] : []));
    _viewContainerRef = inject(ViewContainerRef);
    _viewRef = null;
    _previousData = null;
    constructor() {
        effect(() => {
            const currentData = this.data();
            const recreateView = this.shouldRecreateView(this._previousData, currentData, this.compareBy());
            if (recreateView) {
                const viewContainerRef = this._viewContainerRef;
                if (this._viewRef) {
                    viewContainerRef.remove(viewContainerRef.indexOf(this._viewRef));
                }
                this._viewRef = currentData
                    ? viewContainerRef.createEmbeddedView(currentData.nodeDef.template, currentData.context)
                    : null;
                if (CdkTreeNode.mostRecentTreeNode && this._viewRef) {
                    CdkTreeNode.mostRecentTreeNode.data = currentData.data;
                }
            }
            else if (this._viewRef && currentData.context) {
                this.updateExistingContext(currentData.context);
            }
            // Save the current value as the previous value for the next iteration
            this._previousData = currentData;
        });
    }
    shouldRecreateView(previousData, currentData, compareByFn) {
        const prevCtxKeys = Object.keys(previousData || {});
        const currCtxKeys = Object.keys(currentData || {});
        if (prevCtxKeys.length === currCtxKeys.length) {
            for (const propName of currCtxKeys) {
                if (prevCtxKeys.indexOf(propName) === -1) {
                    return true;
                }
            }
            return compareByFn((previousData?.data ?? null)) !== compareByFn((currentData?.data ?? null));
        }
        return true;
    }
    updateExistingContext(ctx) {
        for (const [key, value] of Object.entries(ctx)) {
            this._viewRef.context[key] = value;
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "21.0.0", ngImport: i0, type: NzTreeVirtualScrollNodeOutletDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "21.0.0", type: NzTreeVirtualScrollNodeOutletDirective, isStandalone: true, selector: "[nzTreeVirtualScrollNodeOutlet]", inputs: { data: { classPropertyName: "data", publicName: "data", isSignal: true, isRequired: true, transformFunction: null }, compareBy: { classPropertyName: "compareBy", publicName: "compareBy", isSignal: true, isRequired: true, transformFunction: null } }, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "21.0.0", ngImport: i0, type: NzTreeVirtualScrollNodeOutletDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[nzTreeVirtualScrollNodeOutlet]'
                }]
        }], ctorParameters: () => [], propDecorators: { data: [{ type: i0.Input, args: [{ isSignal: true, alias: "data", required: true }] }], compareBy: [{ type: i0.Input, args: [{ isSignal: true, alias: "compareBy", required: true }] }] } });

/**
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE
 */
class NzTreeNodeOptionComponent {
    nzSelected = input(false, ...(ngDevMode ? [{ debugName: "nzSelected", transform: booleanAttribute }] : [{ transform: booleanAttribute }]));
    nzDisabled = input(false, ...(ngDevMode ? [{ debugName: "nzDisabled", transform: booleanAttribute }] : [{ transform: booleanAttribute }]));
    nzClick = output();
    ngZone = inject(NgZone);
    element = inject((ElementRef)).nativeElement;
    destroyRef = inject(DestroyRef);
    treeNode = inject((NzTreeNodeComponent));
    get isExpanded() {
        return this.treeNode.isExpanded;
    }
    constructor() {
        effect(() => {
            if (this.nzSelected()) {
                this.treeNode.select();
            }
            else {
                this.treeNode.deselect();
            }
        });
        effect(() => {
            if (this.nzDisabled()) {
                this.treeNode.disable();
            }
            else {
                this.treeNode.enable();
            }
        });
    }
    ngOnInit() {
        fromEventOutsideAngular(this.element, 'click')
            .pipe(filter(() => !this.nzDisabled()), takeUntilDestroyed(this.destroyRef))
            .subscribe(event => {
            this.ngZone.run(() => this.nzClick.emit(event));
        });
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "21.0.0", ngImport: i0, type: NzTreeNodeOptionComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.1.0", version: "21.0.0", type: NzTreeNodeOptionComponent, isStandalone: true, selector: "nz-tree-node-option", inputs: { nzSelected: { classPropertyName: "nzSelected", publicName: "nzSelected", isSignal: true, isRequired: false, transformFunction: null }, nzDisabled: { classPropertyName: "nzDisabled", publicName: "nzDisabled", isSignal: true, isRequired: false, transformFunction: null } }, outputs: { nzClick: "nzClick" }, host: { properties: { "class.ant-tree-node-content-wrapper-open": "isExpanded", "class.ant-tree-node-selected": "nzSelected()" }, classAttribute: "ant-tree-node-content-wrapper" }, ngImport: i0, template: `<span class="ant-tree-title"><ng-content></ng-content></span>`, isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "21.0.0", ngImport: i0, type: NzTreeNodeOptionComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'nz-tree-node-option',
                    template: `<span class="ant-tree-title"><ng-content></ng-content></span>`,
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    host: {
                        class: 'ant-tree-node-content-wrapper',
                        '[class.ant-tree-node-content-wrapper-open]': 'isExpanded',
                        '[class.ant-tree-node-selected]': 'nzSelected()'
                    }
                }]
        }], ctorParameters: () => [], propDecorators: { nzSelected: [{ type: i0.Input, args: [{ isSignal: true, alias: "nzSelected", required: false }] }], nzDisabled: [{ type: i0.Input, args: [{ isSignal: true, alias: "nzDisabled", required: false }] }], nzClick: [{ type: i0.Output, args: ["nzClick"] }] } });

/**
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE
 */
class NzTreeNodeOutletDirective extends CdkTreeNodeOutlet {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "21.0.0", ngImport: i0, type: NzTreeNodeOutletDirective, deps: null, target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "21.0.0", type: NzTreeNodeOutletDirective, isStandalone: true, selector: "[nzTreeNodeOutlet]", providers: [
            {
                provide: CdkTreeNodeOutlet,
                useExisting: forwardRef(() => NzTreeNodeOutletDirective)
            }
        ], usesInheritance: true, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "21.0.0", ngImport: i0, type: NzTreeNodeOutletDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[nzTreeNodeOutlet]',
                    providers: [
                        {
                            provide: CdkTreeNodeOutlet,
                            useExisting: forwardRef(() => NzTreeNodeOutletDirective)
                        }
                    ]
                }]
        }] });

/**
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE
 */
class NzTreeNodePaddingDirective extends CdkTreeNodePadding {
    _indent = 24;
    get level() {
        return this._level;
    }
    set level(value) {
        this._setLevelInput(value);
    }
    get indent() {
        return this._indent;
    }
    set indent(indent) {
        this._setIndentInput(indent);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "21.0.0", ngImport: i0, type: NzTreeNodePaddingDirective, deps: null, target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "16.1.0", version: "21.0.0", type: NzTreeNodePaddingDirective, isStandalone: true, selector: "[nzTreeNodePadding]", inputs: { level: ["nzTreeNodePadding", "level", numberAttribute], indent: ["nzTreeNodePaddingIndent", "indent"] }, providers: [
            {
                provide: CdkTreeNodePadding,
                useExisting: forwardRef(() => NzTreeNodePaddingDirective)
            }
        ], usesInheritance: true, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "21.0.0", ngImport: i0, type: NzTreeNodePaddingDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[nzTreeNodePadding]',
                    providers: [
                        {
                            provide: CdkTreeNodePadding,
                            useExisting: forwardRef(() => NzTreeNodePaddingDirective)
                        }
                    ]
                }]
        }], propDecorators: { level: [{
                type: Input,
                args: [{ alias: 'nzTreeNodePadding', transform: numberAttribute }]
            }], indent: [{
                type: Input,
                args: ['nzTreeNodePaddingIndent']
            }] } });

/**
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE
 */
class NzTreeViewComponent extends NzTreeView {
    nodeOutlet;
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "21.0.0", ngImport: i0, type: NzTreeViewComponent, deps: null, target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "21.0.0", type: NzTreeViewComponent, isStandalone: true, selector: "nz-tree-view", host: { properties: { "class.ant-tree-block-node": "nzDirectoryTree || nzBlockNode", "class.ant-tree-directory": "nzDirectoryTree", "class.ant-tree-rtl": "dir() === 'rtl'" }, classAttribute: "ant-tree" }, providers: [
            NzAnimationTreeCollapseService,
            { provide: CdkTree, useExisting: forwardRef(() => NzTreeViewComponent) },
            { provide: NzTreeView, useExisting: forwardRef(() => NzTreeViewComponent) }
        ], viewQueries: [{ propertyName: "nodeOutlet", first: true, predicate: NzTreeNodeOutletDirective, descendants: true, static: true }], exportAs: ["nzTreeView"], usesInheritance: true, ngImport: i0, template: `
    <div class="ant-tree-list-holder">
      <div class="ant-tree-list-holder-inner">
        <ng-container nzTreeNodeOutlet></ng-container>
      </div>
    </div>
  `, isInline: true, dependencies: [{ kind: "directive", type: NzTreeNodeOutletDirective, selector: "[nzTreeNodeOutlet]" }], changeDetection: i0.ChangeDetectionStrategy.OnPush, encapsulation: i0.ViewEncapsulation.None });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "21.0.0", ngImport: i0, type: NzTreeViewComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'nz-tree-view',
                    exportAs: 'nzTreeView',
                    imports: [NzTreeNodeOutletDirective],
                    template: `
    <div class="ant-tree-list-holder">
      <div class="ant-tree-list-holder-inner">
        <ng-container nzTreeNodeOutlet></ng-container>
      </div>
    </div>
  `,
                    encapsulation: ViewEncapsulation.None,
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    providers: [
                        NzAnimationTreeCollapseService,
                        { provide: CdkTree, useExisting: forwardRef(() => NzTreeViewComponent) },
                        { provide: NzTreeView, useExisting: forwardRef(() => NzTreeViewComponent) }
                    ],
                    host: {
                        class: 'ant-tree',
                        '[class.ant-tree-block-node]': 'nzDirectoryTree || nzBlockNode',
                        '[class.ant-tree-directory]': 'nzDirectoryTree',
                        '[class.ant-tree-rtl]': `dir() === 'rtl'`
                    }
                }]
        }], propDecorators: { nodeOutlet: [{
                type: ViewChild,
                args: [NzTreeNodeOutletDirective, { static: true }]
            }] } });

/**
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE
 */
const DEFAULT_SIZE = 28;
class NzTreeVirtualScrollViewComponent extends NzTreeView {
    _nodeOutlet = undefined;
    virtualScrollViewport;
    nzItemSize = DEFAULT_SIZE;
    nzMinBufferPx = DEFAULT_SIZE * 5;
    nzMaxBufferPx = DEFAULT_SIZE * 10;
    nodes = [];
    innerTrackBy = i => i;
    constructor() {
        super();
        const treeCollapseService = inject(NzAnimationTreeCollapseService);
        treeCollapseService.virtualScroll = true;
    }
    ngOnChanges({ trackBy }) {
        if (trackBy) {
            if (typeof trackBy.currentValue === 'function') {
                this.innerTrackBy = (index, n) => this.trackBy(index, n.data);
            }
            else {
                this.innerTrackBy = i => i;
            }
        }
    }
    compareBy(index) {
        return (value) => (this.trackBy ? this.trackBy(index, value) : value);
    }
    renderNodeChanges(data) {
        /* https://github.com/angular/components/blob/21cc21ea3b280c3f82a19f5ec1b679eb1eee1358/src/cdk/tree/tree.ts#L1103
         * If levelAccessor is used, renderNodes needs to be recalculated, because flattenData (i.e., dataNodes) is used as renderNodes by default in the @angular/components library
         * If childrenAccessor is used, @angular/components library inner will calculate renderNodes.
         */
        const renderNodes = this.levelAccessor ? this.getRenderNodes(data) : [...data];
        this.nodes = renderNodes.map((n, i) => this.createNode(n, i));
        this.dataSourceChanged$.next();
        this.cdr.markForCheck();
    }
    createNode(nodeData, index) {
        const node = this._getNodeDef(nodeData, index);
        const context = new CdkTreeNodeOutletContext(nodeData);
        return {
            data: nodeData,
            context,
            nodeDef: node
        };
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "21.0.0", ngImport: i0, type: NzTreeVirtualScrollViewComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "21.0.0", type: NzTreeVirtualScrollViewComponent, isStandalone: true, selector: "nz-tree-virtual-scroll-view", inputs: { nzItemSize: "nzItemSize", nzMinBufferPx: "nzMinBufferPx", nzMaxBufferPx: "nzMaxBufferPx" }, host: { properties: { "class.ant-tree-block-node": "nzDirectoryTree || nzBlockNode", "class.ant-tree-directory": "nzDirectoryTree", "class.ant-tree-rtl": "dir() === 'rtl'" }, classAttribute: "ant-tree" }, providers: [
            NzAnimationTreeCollapseService,
            { provide: NzTreeView, useExisting: forwardRef(() => NzTreeVirtualScrollViewComponent) },
            { provide: CdkTree, useExisting: forwardRef(() => NzTreeVirtualScrollViewComponent) }
        ], viewQueries: [{ propertyName: "_nodeOutlet", first: true, predicate: NzTreeNodeOutletDirective, descendants: true, static: true }, { propertyName: "virtualScrollViewport", first: true, predicate: CdkVirtualScrollViewport, descendants: true, static: true }], exportAs: ["nzTreeVirtualScrollView"], usesInheritance: true, usesOnChanges: true, ngImport: i0, template: `
    <div class="ant-tree-list">
      <cdk-virtual-scroll-viewport
        class="ant-tree-list-holder"
        [itemSize]="nzItemSize"
        [minBufferPx]="nzMinBufferPx"
        [maxBufferPx]="nzMaxBufferPx"
      >
        <ng-container *cdkVirtualFor="let item of nodes; let i = index; trackBy: innerTrackBy">
          <ng-template nzTreeVirtualScrollNodeOutlet [data]="item" [compareBy]="compareBy(i)"></ng-template>
        </ng-container>
      </cdk-virtual-scroll-viewport>
    </div>
    <ng-container nzTreeNodeOutlet></ng-container>
  `, isInline: true, dependencies: [{ kind: "directive", type: CdkFixedSizeVirtualScroll, selector: "cdk-virtual-scroll-viewport[itemSize]", inputs: ["itemSize", "minBufferPx", "maxBufferPx"] }, { kind: "directive", type: CdkVirtualForOf, selector: "[cdkVirtualFor][cdkVirtualForOf]", inputs: ["cdkVirtualForOf", "cdkVirtualForTrackBy", "cdkVirtualForTemplate", "cdkVirtualForTemplateCacheSize"] }, { kind: "component", type: CdkVirtualScrollViewport, selector: "cdk-virtual-scroll-viewport", inputs: ["orientation", "appendOnly"], outputs: ["scrolledIndexChange"] }, { kind: "directive", type: NzTreeNodeOutletDirective, selector: "[nzTreeNodeOutlet]" }, { kind: "directive", type: NzTreeVirtualScrollNodeOutletDirective, selector: "[nzTreeVirtualScrollNodeOutlet]", inputs: ["data", "compareBy"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush, encapsulation: i0.ViewEncapsulation.None });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "21.0.0", ngImport: i0, type: NzTreeVirtualScrollViewComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'nz-tree-virtual-scroll-view',
                    exportAs: 'nzTreeVirtualScrollView',
                    template: `
    <div class="ant-tree-list">
      <cdk-virtual-scroll-viewport
        class="ant-tree-list-holder"
        [itemSize]="nzItemSize"
        [minBufferPx]="nzMinBufferPx"
        [maxBufferPx]="nzMaxBufferPx"
      >
        <ng-container *cdkVirtualFor="let item of nodes; let i = index; trackBy: innerTrackBy">
          <ng-template nzTreeVirtualScrollNodeOutlet [data]="item" [compareBy]="compareBy(i)"></ng-template>
        </ng-container>
      </cdk-virtual-scroll-viewport>
    </div>
    <ng-container nzTreeNodeOutlet></ng-container>
  `,
                    encapsulation: ViewEncapsulation.None,
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    providers: [
                        NzAnimationTreeCollapseService,
                        { provide: NzTreeView, useExisting: forwardRef(() => NzTreeVirtualScrollViewComponent) },
                        { provide: CdkTree, useExisting: forwardRef(() => NzTreeVirtualScrollViewComponent) }
                    ],
                    host: {
                        class: 'ant-tree',
                        '[class.ant-tree-block-node]': 'nzDirectoryTree || nzBlockNode',
                        '[class.ant-tree-directory]': 'nzDirectoryTree',
                        '[class.ant-tree-rtl]': `dir() === 'rtl'`
                    },
                    imports: [
                        CdkFixedSizeVirtualScroll,
                        CdkVirtualForOf,
                        CdkVirtualScrollViewport,
                        NzTreeNodeOutletDirective,
                        NzTreeVirtualScrollNodeOutletDirective
                    ]
                }]
        }], ctorParameters: () => [], propDecorators: { _nodeOutlet: [{
                type: ViewChild,
                args: [NzTreeNodeOutletDirective, { static: true }]
            }], virtualScrollViewport: [{
                type: ViewChild,
                args: [CdkVirtualScrollViewport, { static: true }]
            }], nzItemSize: [{
                type: Input
            }], nzMinBufferPx: [{
                type: Input
            }], nzMaxBufferPx: [{
                type: Input
            }] } });

/**
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE
 */
const treeWithControlComponents = [
    NzTreeView,
    NzTreeNodeOutletDirective,
    NzTreeViewComponent,
    NzTreeNodeDefDirective,
    NzTreeNodeComponent,
    NzTreeNodeToggleDirective,
    NzTreeNodePaddingDirective,
    NzTreeNodeToggleRotateIconDirective,
    NzTreeNodeToggleActiveIconDirective,
    NzTreeNodeOptionComponent,
    NzTreeNodeNoopToggleDirective,
    NzTreeNodeCheckboxComponent,
    NzTreeNodeIndentsComponent,
    NzTreeVirtualScrollViewComponent,
    NzTreeVirtualScrollNodeOutletDirective,
    NzTreeNodeIndentLineDirective
];
class NzTreeViewModule {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "21.0.0", ngImport: i0, type: NzTreeViewModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "21.0.0", ngImport: i0, type: NzTreeViewModule, imports: [NzTreeView,
            NzTreeNodeOutletDirective,
            NzTreeViewComponent,
            NzTreeNodeDefDirective,
            NzTreeNodeComponent,
            NzTreeNodeToggleDirective,
            NzTreeNodePaddingDirective,
            NzTreeNodeToggleRotateIconDirective,
            NzTreeNodeToggleActiveIconDirective,
            NzTreeNodeOptionComponent,
            NzTreeNodeNoopToggleDirective,
            NzTreeNodeCheckboxComponent,
            NzTreeNodeIndentsComponent,
            NzTreeVirtualScrollViewComponent,
            NzTreeVirtualScrollNodeOutletDirective,
            NzTreeNodeIndentLineDirective], exports: [NzTreeView,
            NzTreeNodeOutletDirective,
            NzTreeViewComponent,
            NzTreeNodeDefDirective,
            NzTreeNodeComponent,
            NzTreeNodeToggleDirective,
            NzTreeNodePaddingDirective,
            NzTreeNodeToggleRotateIconDirective,
            NzTreeNodeToggleActiveIconDirective,
            NzTreeNodeOptionComponent,
            NzTreeNodeNoopToggleDirective,
            NzTreeNodeCheckboxComponent,
            NzTreeNodeIndentsComponent,
            NzTreeVirtualScrollViewComponent,
            NzTreeVirtualScrollNodeOutletDirective,
            NzTreeNodeIndentLineDirective] });
    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "21.0.0", ngImport: i0, type: NzTreeViewModule, imports: [NzTreeVirtualScrollViewComponent] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "21.0.0", ngImport: i0, type: NzTreeViewModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [treeWithControlComponents],
                    exports: [treeWithControlComponents]
                }]
        }] });

/**
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE
 */
class NzTreeFlattener {
    transformFunction;
    getLevel;
    isExpandable;
    getChildren;
    constructor(transformFunction, getLevel, isExpandable, getChildren) {
        this.transformFunction = transformFunction;
        this.getLevel = getLevel;
        this.isExpandable = isExpandable;
        this.getChildren = getChildren;
    }
    flattenNode(node, level, resultNodes, parentMap) {
        const flatNode = this.transformFunction(node, level);
        resultNodes.push(flatNode);
        if (this.isExpandable(flatNode)) {
            const childrenNodes = this.getChildren(node);
            if (childrenNodes) {
                if (Array.isArray(childrenNodes)) {
                    this.flattenChildren(childrenNodes, level, resultNodes, parentMap);
                }
                else {
                    childrenNodes.pipe(take(1)).subscribe(children => {
                        this.flattenChildren(children, level, resultNodes, parentMap);
                    });
                }
            }
        }
        return resultNodes;
    }
    flattenChildren(children, level, resultNodes, parentMap) {
        children.forEach((child, index) => {
            const childParentMap = parentMap.slice();
            childParentMap.push(index !== children.length - 1);
            this.flattenNode(child, level + 1, resultNodes, childParentMap);
        });
    }
    /**
     * Flatten a list of node type T to flattened version of node F.
     * Please note that type T may be nested, and the length of `structuredData` may be different
     * from that of returned list `F[]`.
     */
    flattenNodes(structuredData) {
        const resultNodes = [];
        structuredData.forEach(node => this.flattenNode(node, 0, resultNodes, []));
        return resultNodes;
    }
}

/**
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE
 */
class NzTreeViewFlatDataSource extends DataSource {
    _tree;
    _treeFlattener;
    initialData;
    _flattenedData = new BehaviorSubject([]);
    _data = new BehaviorSubject([]);
    constructor(_tree, _treeFlattener, initialData = []) {
        super();
        this._tree = _tree;
        this._treeFlattener = _treeFlattener;
        this.initialData = initialData;
        this.setData(initialData);
    }
    setData(data) {
        this._data.next(data);
        this.setFlattenedData(this.flatten(data));
    }
    getData() {
        return this._data.getValue();
    }
    getFlattenData() {
        return this._flattenedData.getValue();
    }
    setFlattenedData(nodes) {
        this._flattenedData.next(nodes);
        this.setDataNodes(nodes);
    }
    connect(collectionViewer) {
        return merge(collectionViewer.viewChange, this._flattenedData.asObservable()).pipe(map(() => this.getFlattenData()));
    }
    disconnect() {
        // no op
    }
    setDataNodes(nodes) {
        this._tree.dataNodes = nodes;
    }
    flatten(data) {
        return this._treeFlattener.flattenNodes(data);
    }
}

/**
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE
 */
class NzTreeViewNestedDataSource extends DataSource {
    _tree;
    initialData;
    _data = new BehaviorSubject([]);
    constructor(_tree, initialData = []) {
        super();
        this._tree = _tree;
        this.initialData = initialData;
        this.setData(initialData);
    }
    setData(value) {
        this._data.next(value);
        this.setTreeDataNodes(value);
    }
    getData() {
        return this._data.getValue();
    }
    connect(collectionViewer) {
        return merge(collectionViewer.viewChange, this._data.asObservable()).pipe(map(() => this.getData()));
    }
    disconnect() {
        // no op
    }
    setTreeDataNodes(nodes) {
        this._tree.dataNodes = nodes;
    }
}

/**
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE
 */

/**
 * Generated bundle index. Do not edit.
 */

export { NzTreeFlattener, NzTreeNodeCheckboxComponent, NzTreeNodeComponent, NzTreeNodeDefDirective, NzTreeNodeIndentLineDirective, NzTreeNodeIndentsComponent, NzTreeNodeNoopToggleDirective, NzTreeNodeOptionComponent, NzTreeNodeOutletDirective, NzTreeNodePaddingDirective, NzTreeNodeToggleActiveIconDirective, NzTreeNodeToggleDirective, NzTreeNodeToggleRotateIconDirective, NzTreeView, NzTreeViewComponent, NzTreeViewFlatDataSource, NzTreeViewModule, NzTreeViewNestedDataSource, NzTreeVirtualScrollNodeOutletDirective, NzTreeVirtualScrollViewComponent, flattenNestedNodes, getDescendants, getDescendantsForNestedData, getNextSibling, getNextSiblingForNestedData, getParent, getParentForNestedData };
//# sourceMappingURL=ng-zorro-antd-tree-view.mjs.map
