import * as _angular_core from '@angular/core';
import { Signal, TemplateRef } from '@angular/core';
import { NzQRCodeI18nInterface } from 'ng-zorro-antd/i18n';

/**
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE
 */

interface Excavation {
    x: number;
    y: number;
    w: number;
    h: number;
}
type ErrorCorrectionLevel = 'L' | 'M' | 'Q' | 'H';
type CrossOrigin = 'anonymous' | 'use-credentials' | '' | undefined;
interface ImageSettings {
    /**
     * The URI of the embedded image.
     */
    src: string;
    /**
     * The height, in pixels, of the image.
     */
    height: number;
    /**
     * The width, in pixels, of the image.
     */
    width: number;
    /**
     * Whether or not to "excavate" the modules around the embedded image. This
     * means that any modules the embedded image overlaps will use the background
     * color.
     */
    excavate: boolean;
    /**
     * The horizontal offset of the embedded image, starting from the top left corner.
     * Will center if not specified.
     */
    x?: number;
    /**
     * The vertical offset of the embedded image, starting from the top left corner.
     * Will center if not specified.
     */
    y?: number;
    /**
     * The opacity of the embedded image in the range of 0-1.
     * @defaultValue 1
     */
    opacity?: number;
    /**
     * The cross-origin value to use when loading the image. This is used to
     * ensure compatibility with CORS, particularly when extracting image data
     * from QRCodeCanvas.
     * Note: `undefined` is treated differently than the seemingly equivalent
     * empty string. This is intended to align with HTML behavior where omitting
     * the attribute behaves differently than the empty string.
     */
    crossOrigin?: CrossOrigin;
}

declare class NzQRCodeComponent {
    private i18n;
    locale: Signal<NzQRCodeI18nInterface>;
    protected isBrowser: boolean;
    readonly nzValue: _angular_core.InputSignal<string | string[]>;
    readonly nzType: _angular_core.InputSignal<"canvas" | "svg">;
    readonly nzColor: _angular_core.InputSignal<string>;
    readonly nzBgColor: _angular_core.InputSignal<string>;
    readonly nzSize: _angular_core.InputSignal<number>;
    readonly nzIcon: _angular_core.InputSignal<string>;
    readonly nzIconSize: _angular_core.InputSignal<number>;
    readonly nzBordered: _angular_core.InputSignal<boolean>;
    readonly nzStatus: _angular_core.InputSignal<"active" | "expired" | "loading" | "scanned">;
    readonly nzLevel: _angular_core.InputSignal<ErrorCorrectionLevel>;
    readonly nzStatusRender: _angular_core.InputSignal<string | TemplateRef<void> | null>;
    readonly nzBoostLevel: _angular_core.InputSignal<boolean>;
    readonly nzPadding: _angular_core.InputSignal<number>;
    readonly nzRefresh: _angular_core.OutputEmitterRef<string>;
    margin: _angular_core.WritableSignal<number>;
    cells: _angular_core.WritableSignal<boolean[][]>;
    numCells: _angular_core.WritableSignal<number>;
    calculatedImageSettings: _angular_core.WritableSignal<{
        x: number;
        y: number;
        h: number;
        w: number;
        excavation: Excavation | null;
        opacity: number;
        crossOrigin: CrossOrigin;
    } | null>;
    protected imageSettings: Signal<ImageSettings>;
    constructor();
    reloadQRCode(): void;
    updateQRCodeData(): void;
    static ɵfac: _angular_core.ɵɵFactoryDeclaration<NzQRCodeComponent, never>;
    static ɵcmp: _angular_core.ɵɵComponentDeclaration<NzQRCodeComponent, "nz-qrcode", ["nzQRCode"], { "nzValue": { "alias": "nzValue"; "required": false; "isSignal": true; }; "nzType": { "alias": "nzType"; "required": false; "isSignal": true; }; "nzColor": { "alias": "nzColor"; "required": false; "isSignal": true; }; "nzBgColor": { "alias": "nzBgColor"; "required": false; "isSignal": true; }; "nzSize": { "alias": "nzSize"; "required": false; "isSignal": true; }; "nzIcon": { "alias": "nzIcon"; "required": false; "isSignal": true; }; "nzIconSize": { "alias": "nzIconSize"; "required": false; "isSignal": true; }; "nzBordered": { "alias": "nzBordered"; "required": false; "isSignal": true; }; "nzStatus": { "alias": "nzStatus"; "required": false; "isSignal": true; }; "nzLevel": { "alias": "nzLevel"; "required": false; "isSignal": true; }; "nzStatusRender": { "alias": "nzStatusRender"; "required": false; "isSignal": true; }; "nzBoostLevel": { "alias": "nzBoostLevel"; "required": false; "isSignal": true; }; "nzPadding": { "alias": "nzPadding"; "required": false; "isSignal": true; }; }, { "nzRefresh": "nzRefresh"; }, never, never, true, never>;
}

declare class NzQRCodeModule {
    static ɵfac: _angular_core.ɵɵFactoryDeclaration<NzQRCodeModule, never>;
    static ɵmod: _angular_core.ɵɵNgModuleDeclaration<NzQRCodeModule, never, [typeof NzQRCodeComponent], [typeof NzQRCodeComponent]>;
    static ɵinj: _angular_core.ɵɵInjectorDeclaration<NzQRCodeModule>;
}

export { NzQRCodeComponent, NzQRCodeModule };
