import * as rxjs from 'rxjs';
import { Subject } from 'rxjs';
import { ComponentType } from '@angular/cdk/overlay';
import * as i0 from '@angular/core';
import { TemplateRef, OnInit, EventEmitter, DestroyRef, ElementRef, Signal, ChangeDetectorRef, Injector } from '@angular/core';
import { MessageConfig, NzConfigService } from 'ng-zorro-antd/core/config';
import { NzSingletonService } from 'ng-zorro-antd/core/services';
import { NzSafeAny, NgStyleInterface, NgClassInterface } from 'ng-zorro-antd/core/types';
import { Direction } from '@angular/cdk/bidi';

/**
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE
 */

type NzMessageType = 'success' | 'info' | 'warning' | 'error' | 'loading';
type NzMessageContentType = string | TemplateRef<void | {
    $implicit: NzMNComponent;
    data: NzSafeAny;
}>;
interface NzMessageDataOptions {
    nzDuration?: number;
    nzAnimate?: boolean;
    nzPauseOnHover?: boolean;
    nzData?: NzSafeAny;
    nzStyle?: NgStyleInterface | string;
    nzClass?: NgClassInterface | string;
}
interface NzMessageData {
    type?: NzMessageType | string;
    content?: NzMessageContentType;
    messageId?: string;
    createdAt?: Date;
    options?: NzMessageDataOptions;
    /**
     * @deprecated Will be removed in v22.0.0
     */
    state?: 'enter' | 'leave';
    onClose?: Subject<boolean>;
}
type NzMessageRef = Pick<Required<NzMessageData>, 'onClose' | 'messageId'>;

declare abstract class NzMNService<T extends NzMNContainerComponent> {
    protected abstract componentPrefix: string;
    protected container?: T;
    protected nzSingletonService: NzSingletonService;
    protected injector: Injector;
    remove(id?: string): void;
    protected getInstanceId(): string;
    protected withContainer(ctor: ComponentType<T>): T;
}
declare abstract class NzMNContainerComponent<C extends MessageConfig = MessageConfig, D extends NzMessageData = NzMessageData> {
    config?: Required<C>;
    instances: Array<Required<D>>;
    private readonly _afterAllInstancesRemoved;
    readonly afterAllInstancesRemoved: rxjs.Observable<void>;
    protected cdr: ChangeDetectorRef;
    protected nzConfigService: NzConfigService;
    constructor();
    create(data: D): Required<D>;
    remove(id: string, userAction?: boolean): void;
    removeAll(): void;
    protected onCreate(instance: D): Required<D>;
    protected onRemove(instance: Required<D>, userAction: boolean): void;
    private onAllInstancesRemoved;
    protected readyInstances(): void;
    protected abstract subscribeConfigChange(): void;
    protected mergeOptions(options?: D['options']): D['options'];
    static ɵfac: i0.ɵɵFactoryDeclaration<NzMNContainerComponent<any, any>, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<NzMNContainerComponent<any, any>, never, never, {}, {}, never, never, true, never>;
}
declare abstract class NzMNComponent implements OnInit {
    abstract instance: Required<NzMessageData>;
    abstract index?: number;
    abstract destroyed: EventEmitter<{
        id: string;
        userAction: boolean;
    }>;
    protected destroyRef: DestroyRef;
    protected elementRef: ElementRef<any>;
    /**
     * To get the element which triggers the animation.
     */
    protected abstract animationElement: Signal<ElementRef<HTMLElement>>;
    /**
     * When the animation is enabled, it is used to judge whether the leave animation is done or not.
     * @note Keyframe of notification may have different keyframe names with individual placements, so use array here.
     */
    protected abstract _animationKeyframeMap: Record<'enter' | 'leave', string | string[]>;
    /**
     * The animation class map for enter and leave.
     */
    protected abstract _animationClassMap: Record<'enter' | 'leave', string>;
    protected options: Required<NzMessageDataOptions>;
    protected autoClose?: boolean;
    protected userAction: boolean;
    protected eraseTimer?: ReturnType<typeof setTimeout>;
    protected eraseTimingStart?: number;
    protected eraseTTL: number;
    constructor();
    ngOnInit(): void;
    onEnter(): void;
    onLeave(): void;
    protected destroy(userAction?: boolean): void;
    private initErase;
    private updateTTL;
    private startEraseTimeout;
    private clearEraseTimeout;
    private _startEnterAnimation;
    private _startLeaveAnimation;
    private matchAnimationKeyframe;
    static ɵfac: i0.ɵɵFactoryDeclaration<NzMNComponent, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<NzMNComponent, never, never, {}, {}, never, never, true, never>;
}

/**
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE
 */

declare class NzMessageContainerComponent extends NzMNContainerComponent {
    dir: Direction;
    top?: string | null;
    constructor();
    protected subscribeConfigChange(): void;
    protected updateConfig(): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<NzMessageContainerComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<NzMessageContainerComponent, "nz-message-container", ["nzMessageContainer"], {}, {}, never, never, true, never>;
}

declare class NzMessageComponent extends NzMNComponent implements OnInit {
    instance: Required<NzMessageData>;
    readonly destroyed: EventEmitter<{
        id: string;
        userAction: boolean;
    }>;
    index?: number;
    readonly animationElement: i0.Signal<ElementRef<any>>;
    protected readonly _animationKeyframeMap: {
        enter: string;
        leave: string;
    };
    protected readonly _animationClassMap: {
        enter: string;
        leave: string;
    };
    static ɵfac: i0.ɵɵFactoryDeclaration<NzMessageComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<NzMessageComponent, "nz-message", ["nzMessage"], { "instance": { "alias": "instance"; "required": false; }; }, { "destroyed": "destroyed"; }, never, never, true, never>;
}

declare class NzMessageService extends NzMNService<NzMessageContainerComponent> {
    protected componentPrefix: string;
    success(content: NzMessageContentType, options?: NzMessageDataOptions): NzMessageRef;
    error(content: NzMessageContentType, options?: NzMessageDataOptions): NzMessageRef;
    info(content: NzMessageContentType, options?: NzMessageDataOptions): NzMessageRef;
    warning(content: NzMessageContentType, options?: NzMessageDataOptions): NzMessageRef;
    loading(content: NzMessageContentType, options?: NzMessageDataOptions): NzMessageRef;
    create(type: NzMessageType | string, content: NzMessageContentType, options?: NzMessageDataOptions): NzMessageRef;
    private createInstance;
    static ɵfac: i0.ɵɵFactoryDeclaration<NzMessageService, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<NzMessageService>;
}

export { NzMNComponent, NzMNContainerComponent, NzMNService, NzMessageComponent, NzMessageContainerComponent, NzMessageService };
export type { NzMessageContentType, NzMessageData, NzMessageDataOptions, NzMessageRef, NzMessageType };
