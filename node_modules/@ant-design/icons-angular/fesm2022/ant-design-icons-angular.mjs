import { HttpBackend, HttpClient } from '@angular/common/http';
import * as i0 from '@angular/core';
import { isDevMode, InjectionToken, inject, RendererFactory2, DOCUMENT, SecurityContext, Optional, Inject, Injectable, ElementRef, Renderer2, Input, Directive, makeEnvironmentProviders } from '@angular/core';
import { DomSanitizer } from '@angular/platform-browser';
import { Subject, of, Observable } from 'rxjs';
import { map, tap, finalize, catchError, share, filter, take } from 'rxjs/operators';
import { generate } from '@ant-design/colors';

const ANT_ICON_ANGULAR_CONSOLE_PREFIX = '[@ant-design/icons-angular]:';
function error(message) {
    console.error(`${ANT_ICON_ANGULAR_CONSOLE_PREFIX} ${message}.`);
}
function warn(message) {
    if (isDevMode()) {
        console.warn(`${ANT_ICON_ANGULAR_CONSOLE_PREFIX} ${message}.`);
    }
}
function getSecondaryColor(primaryColor) {
    return generate(primaryColor)[0];
}
function withSuffix(name, theme) {
    switch (theme) {
        case 'fill':
            return `${name}-fill`;
        case 'outline':
            return `${name}-o`;
        case 'twotone':
            return `${name}-twotone`;
        case undefined:
            return name;
        default:
            throw new Error(`${ANT_ICON_ANGULAR_CONSOLE_PREFIX}Theme "${theme}" is not a recognized theme!`);
    }
}
function withSuffixAndColor(name, theme, pri, sec) {
    return `${withSuffix(name, theme)}-${pri}-${sec}`;
}
function mapAbbrToTheme(abbr) {
    return abbr === 'o' ? 'outline' : abbr;
}
function alreadyHasAThemeSuffix(name) {
    return name.endsWith('-fill') || name.endsWith('-o') || name.endsWith('-twotone');
}
function isIconDefinition(target) {
    return (typeof target === 'object' &&
        typeof target.name === 'string' &&
        (typeof target.theme === 'string' || target.theme === undefined) &&
        typeof target.icon === 'string');
}
/**
 * Get an `IconDefinition` object from abbreviation type, like `account-book-fill`.
 * @param str
 */
function getIconDefinitionFromAbbr(str) {
    const arr = str.split('-');
    const theme = mapAbbrToTheme(arr.splice(arr.length - 1, 1)[0]);
    const name = arr.join('-');
    return {
        name,
        theme,
        icon: ''
    };
}
function cloneSVG(svg) {
    return svg.cloneNode(true);
}
/**
 * Parse inline SVG string and replace colors with placeholders. For twotone icons only.
 */
function replaceFillColor(raw) {
    return raw
        .replace(/['"]#333['"]/g, '"primaryColor"')
        .replace(/['"]#E6E6E6['"]/g, '"secondaryColor"')
        .replace(/['"]#D9D9D9['"]/g, '"secondaryColor"')
        .replace(/['"]#D8D8D8['"]/g, '"secondaryColor"');
}
/**
 * Split a name with namespace in it into a tuple like [ name, namespace ].
 */
function getNameAndNamespace(type) {
    const split = type.split(':');
    switch (split.length) {
        case 1:
            return [type, ''];
        case 2:
            return [split[1], split[0]];
        default:
            throw new Error(`${ANT_ICON_ANGULAR_CONSOLE_PREFIX}The icon type ${type} is not valid!`);
    }
}
function hasNamespace(type) {
    return getNameAndNamespace(type)[1] !== '';
}

function NameSpaceIsNotSpecifyError() {
    return new Error(`${ANT_ICON_ANGULAR_CONSOLE_PREFIX}Type should have a namespace. Try "namespace:${name}".`);
}
function IconNotFoundError(icon) {
    return new Error(`${ANT_ICON_ANGULAR_CONSOLE_PREFIX}the icon ${icon} does not exist or is not registered.`);
}
function HttpModuleNotImport() {
    error(`you need to import "HttpClientModule" to use dynamic importing.`);
    return null;
}
function UrlNotSafeError(url) {
    return new Error(`${ANT_ICON_ANGULAR_CONSOLE_PREFIX}The url "${url}" is unsafe.`);
}
function SVGTagNotFoundError() {
    return new Error(`${ANT_ICON_ANGULAR_CONSOLE_PREFIX}<svg> tag not found.`);
}
function DynamicLoadingTimeoutError() {
    return new Error(`${ANT_ICON_ANGULAR_CONSOLE_PREFIX}Importing timeout error.`);
}

const JSONP_HANDLER_NAME = '__ant_icon_load';
const ANT_ICONS = new InjectionToken('ant_icons');
class IconService {
    _antIcons;
    defaultTheme = 'outline';
    set twoToneColor({ primaryColor, secondaryColor }) {
        this._twoToneColorPalette.primaryColor = primaryColor;
        this._twoToneColorPalette.secondaryColor = secondaryColor || getSecondaryColor(primaryColor);
    }
    get twoToneColor() {
        // Make a copy to avoid unexpected changes.
        return { ...this._twoToneColorPalette };
    }
    _renderer;
    _http;
    /**
     * Disable dynamic loading (support static loading only).
     */
    get _disableDynamicLoading() {
        return false;
    }
    /**
     * All icon definitions would be registered here.
     */
    _svgDefinitions = new Map();
    /**
     * Cache all rendered icons. Icons are identified by name, theme,
     * and for twotone icons, primary color and secondary color.
     */
    _svgRenderedDefinitions = new Map();
    _inProgressFetches = new Map();
    /**
     * Url prefix for fetching inline SVG by dynamic importing.
     */
    _assetsUrlRoot = '';
    _twoToneColorPalette = {
        primaryColor: '#333333',
        secondaryColor: '#E6E6E6'
    };
    /** A flag indicates whether jsonp loading is enabled. */
    _enableJsonpLoading = false;
    _jsonpIconLoad$ = new Subject();
    _rendererFactory = inject(RendererFactory2);
    _handler = inject(HttpBackend, { optional: true });
    _document = inject(DOCUMENT);
    sanitizer = inject(DomSanitizer);
    constructor(_antIcons) {
        this._antIcons = _antIcons;
        this._renderer = this._rendererFactory.createRenderer(null, null);
        if (this._handler) {
            this._http = new HttpClient(this._handler);
        }
        if (this._antIcons) {
            this.addIcon(...this._antIcons);
        }
    }
    /**
     * Call this method to switch to jsonp like loading.
     */
    useJsonpLoading() {
        if (!this._enableJsonpLoading) {
            this._enableJsonpLoading = true;
            window[JSONP_HANDLER_NAME] = (icon) => {
                this._jsonpIconLoad$.next(icon);
            };
        }
        else {
            warn('You are already using jsonp loading.');
        }
    }
    /**
     * Change the prefix of the inline svg resources, so they could be deployed elsewhere, like CDN.
     * @param prefix
     */
    changeAssetsSource(prefix) {
        this._assetsUrlRoot = prefix.endsWith('/') ? prefix : prefix + '/';
    }
    /**
     * Add icons provided by ant design.
     * @param icons
     */
    addIcon(...icons) {
        icons.forEach(icon => {
            this._svgDefinitions.set(withSuffix(icon.name, icon.theme), icon);
        });
    }
    /**
     * Register an icon. Namespace is required.
     * @param type
     * @param literal
     */
    addIconLiteral(type, literal) {
        const [_, namespace] = getNameAndNamespace(type);
        if (!namespace) {
            throw NameSpaceIsNotSpecifyError();
        }
        this.addIcon({ name: type, icon: literal });
    }
    /**
     * Remove all cache.
     */
    clear() {
        this._svgDefinitions.clear();
        this._svgRenderedDefinitions.clear();
    }
    /**
     * Get a rendered `SVGElement`.
     * @param icon
     * @param twoToneColor
     */
    getRenderedContent(icon, twoToneColor) {
        // If `icon` is a `IconDefinition`, go to the next step. If not, try to fetch it from cache.
        const definition = isIconDefinition(icon)
            ? icon
            : this._svgDefinitions.get(icon) || null;
        if (!definition && this._disableDynamicLoading) {
            throw IconNotFoundError(icon);
        }
        // If `icon` is a `IconDefinition` of successfully fetch, wrap it in an `Observable`.
        // Otherwise try to fetch it from remote.
        const $iconDefinition = definition ? of(definition) : this._loadIconDynamically(icon);
        // If finally get an `IconDefinition`, render and return it. Otherwise throw an error.
        return $iconDefinition.pipe(map(i => {
            if (!i) {
                throw IconNotFoundError(icon);
            }
            return this._loadSVGFromCacheOrCreateNew(i, twoToneColor);
        }));
    }
    getCachedIcons() {
        return this._svgDefinitions;
    }
    /**
     * Get raw svg and assemble a `IconDefinition` object.
     * @param type
     */
    _loadIconDynamically(type) {
        // If developer doesn't provide HTTP module nor enable jsonp loading, just throw an error.
        if (!this._http && !this._enableJsonpLoading) {
            return of(HttpModuleNotImport());
        }
        // If multi directive ask for the same icon at the same time,
        // request should only be fired once.
        let inProgress = this._inProgressFetches.get(type);
        if (!inProgress) {
            const [name, namespace] = getNameAndNamespace(type);
            // If the string has a namespace within, create a simple `IconDefinition`.
            const icon = namespace ? { name: type, icon: '' } : getIconDefinitionFromAbbr(name);
            const suffix = this._enableJsonpLoading ? '.js' : '.svg';
            const url = (namespace
                ? `${this._assetsUrlRoot}assets/${namespace}/${name}`
                : `${this._assetsUrlRoot}assets/${icon.theme}/${icon.name}`) + suffix;
            const safeUrl = this.sanitizer.sanitize(SecurityContext.URL, url);
            if (!safeUrl) {
                throw UrlNotSafeError(url);
            }
            const source = !this._enableJsonpLoading
                ? this._http.get(safeUrl, { responseType: 'text' }).pipe(map(literal => ({ ...icon, icon: literal })))
                : this._loadIconDynamicallyWithJsonp(icon, safeUrl);
            inProgress = source.pipe(tap(definition => this.addIcon(definition)), finalize(() => this._inProgressFetches.delete(type)), catchError(() => of(null)), share());
            this._inProgressFetches.set(type, inProgress);
        }
        return inProgress;
    }
    _loadIconDynamicallyWithJsonp(icon, url) {
        return new Observable(subscriber => {
            const loader = this._document.createElement('script');
            const timer = setTimeout(() => {
                clean();
                subscriber.error(DynamicLoadingTimeoutError());
            }, 6000);
            loader.src = url;
            function clean() {
                loader.parentNode.removeChild(loader);
                clearTimeout(timer);
            }
            this._document.body.appendChild(loader);
            this._jsonpIconLoad$
                .pipe(filter(i => i.name === icon.name && i.theme === icon.theme), take(1))
                .subscribe(i => {
                subscriber.next(i);
                clean();
            });
        });
    }
    /**
     * Render a new `SVGElement` for a given `IconDefinition`, or make a copy from cache.
     * @param icon
     * @param twoToneColor
     */
    _loadSVGFromCacheOrCreateNew(icon, twoToneColor) {
        let svg;
        const pri = twoToneColor || this._twoToneColorPalette.primaryColor;
        const sec = getSecondaryColor(pri) || this._twoToneColorPalette.secondaryColor;
        const key = icon.theme === 'twotone'
            ? withSuffixAndColor(icon.name, icon.theme, pri, sec)
            : icon.theme === undefined
                ? icon.name
                : withSuffix(icon.name, icon.theme);
        // Try to make a copy from cache.
        const cached = this._svgRenderedDefinitions.get(key);
        if (cached) {
            svg = cached.icon;
        }
        else {
            svg = this._setSVGAttribute(this._colorizeSVGIcon(
            // Icons provided by ant design should be refined to remove preset colors.
            this._createSVGElementFromString(hasNamespace(icon.name) ? icon.icon : replaceFillColor(icon.icon)), icon.theme === 'twotone', pri, sec));
            // Cache it.
            this._svgRenderedDefinitions.set(key, {
                ...icon,
                icon: svg
            });
        }
        return cloneSVG(svg);
    }
    _createSVGElementFromString(str) {
        const div = this._document.createElement('div');
        div.innerHTML = str;
        const svg = div.querySelector('svg');
        if (!svg) {
            throw SVGTagNotFoundError;
        }
        return svg;
    }
    _setSVGAttribute(svg) {
        this._renderer.setAttribute(svg, 'width', '1em');
        this._renderer.setAttribute(svg, 'height', '1em');
        return svg;
    }
    _colorizeSVGIcon(svg, twotone, pri, sec) {
        if (twotone) {
            const children = svg.childNodes;
            const length = children.length;
            for (let i = 0; i < length; i++) {
                const child = children[i];
                if (child.getAttribute('fill') === 'secondaryColor') {
                    this._renderer.setAttribute(child, 'fill', sec);
                }
                else {
                    this._renderer.setAttribute(child, 'fill', pri);
                }
            }
        }
        this._renderer.setAttribute(svg, 'fill', 'currentColor');
        return svg;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "21.0.0", ngImport: i0, type: IconService, deps: [{ token: ANT_ICONS, optional: true }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "21.0.0", ngImport: i0, type: IconService, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "21.0.0", ngImport: i0, type: IconService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }], ctorParameters: () => [{ type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [ANT_ICONS]
                }] }] });

function checkMeta(prev, after) {
    return prev.type === after.type && prev.theme === after.theme && prev.twoToneColor === after.twoToneColor;
}
class IconDirective {
    _iconService;
    type;
    theme;
    twoToneColor;
    _elementRef = inject(ElementRef);
    _renderer = inject(Renderer2);
    constructor(_iconService) {
        this._iconService = _iconService;
    }
    ngOnChanges(changes) {
        if (changes.type || changes.theme || changes.twoToneColor) {
            this._changeIcon();
        }
    }
    /**
     * Render a new icon in the current element. Remove the icon when `type` is falsy.
     */
    _changeIcon() {
        return new Promise(resolve => {
            if (!this.type) {
                this._clearSVGElement();
                resolve(null);
                return;
            }
            const beforeMeta = this._getSelfRenderMeta();
            this._iconService
                .getRenderedContent(this._parseIconType(this.type, this.theme), this.twoToneColor)
                .subscribe(svg => {
                // avoid race condition
                // see https://github.com/ant-design/ant-design-icons/issues/315
                const afterMeta = this._getSelfRenderMeta();
                if (checkMeta(beforeMeta, afterMeta)) {
                    this._setSVGElement(svg);
                    resolve(svg);
                }
                else {
                    resolve(null);
                }
            });
        });
    }
    _getSelfRenderMeta() {
        return {
            type: this.type,
            theme: this.theme,
            twoToneColor: this.twoToneColor
        };
    }
    /**
     * Parse a icon to the standard form, an `IconDefinition` or a string like 'account-book-fill` (with a theme suffixed).
     * If namespace is specified, ignore theme because it meaningless for users' icons.
     *
     * @param type
     * @param theme
     */
    _parseIconType(type, theme) {
        if (isIconDefinition(type)) {
            return type;
        }
        else {
            const [name, namespace] = getNameAndNamespace(type);
            if (namespace) {
                return type;
            }
            if (alreadyHasAThemeSuffix(name)) {
                if (theme) {
                    warn(`'type' ${name} already gets a theme inside so 'theme' ${theme} would be ignored`);
                }
                return name;
            }
            else {
                return withSuffix(name, theme || this._iconService.defaultTheme);
            }
        }
    }
    _setSVGElement(svg) {
        this._clearSVGElement();
        this._renderer.appendChild(this._elementRef.nativeElement, svg);
    }
    _clearSVGElement() {
        const el = this._elementRef.nativeElement;
        const children = el.childNodes;
        const length = children.length;
        for (let i = length - 1; i >= 0; i--) {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            const child = children[i];
            if (child.tagName?.toLowerCase() === 'svg') {
                this._renderer.removeChild(el, child);
            }
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "21.0.0", ngImport: i0, type: IconDirective, deps: [{ token: IconService }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "21.0.0", type: IconDirective, isStandalone: true, selector: "[antIcon]", inputs: { type: "type", theme: "theme", twoToneColor: "twoToneColor" }, usesOnChanges: true, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "21.0.0", ngImport: i0, type: IconDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[antIcon]'
                }]
        }], ctorParameters: () => [{ type: IconService }], propDecorators: { type: [{
                type: Input
            }], theme: [{
                type: Input
            }], twoToneColor: [{
                type: Input
            }] } });

/**
 * Provide icon definitions in root
 *
 * @param icons Icon definitions
 */
function provideAntIcons(icons) {
    return makeEnvironmentProviders([
        {
            provide: ANT_ICONS,
            useValue: icons
        }
    ]);
}

const manifest = {
    fill: [
        'account-book', 'alert', 'alipay-circle', 'alipay-square', 'aliwangwang', 'android', 'amazon-circle', 'api', 'apple', 'amazon-square', 'appstore', 'audio', 'backward', 'behance-square', 'bell', 'behance-circle', 'bilibili', 'book', 'box-plot', 'bug', 'build', 'calculator', 'bank', 'calendar', 'bulb', 'camera', 'car', 'caret-down', 'caret-up', 'caret-left', 'caret-right', 'carry-out', 'check-circle', 'chrome', 'check-square', 'clock-circle', 'ci-circle', 'close-circle', 'close-square', 'cloud', 'code-sandbox-square', 'code', 'codepen-circle', 'code-sandbox-circle', 'compass', 'container', 'codepen-square', 'control', 'contacts', 'credit-card', 'copyright-circle', 'copy', 'crown', 'customer-service', 'dashboard', 'delete', 'diff', 'dingtalk-square', 'dingtalk-circle', 'discord', 'dollar-circle', 'database', 'dislike', 'down-circle', 'down-square', 'dribbble-circle', 'dropbox-circle', 'dribbble-square', 'edit', 'environment', 'dropbox-square', 'exclamation-circle', 'euro-circle', 'experiment', 'facebook', 'eye', 'eye-invisible', 'fast-forward', 'fast-backward', 'file-add', 'file-excel', 'file-exclamation', 'file', 'file-markdown', 'file-image', 'file-pdf', 'file-ppt', 'file-text', 'file-word', 'file-zip', 'fire', 'flag', 'filter', 'folder', 'folder-open', 'folder-add', 'frown', 'format-painter', 'funnel-plot', 'file-unknown', 'fund', 'github', 'gitlab', 'gift', 'forward', 'gold', 'google-circle', 'golden', 'google-plus-circle', 'google-plus-square', 'google-square', 'heart', 'hdd', 'home', 'html5', 'ie-circle', 'hourglass', 'ie-square', 'highlight', 'idcard', 'info-circle', 'interaction', 'instagram', 'insurance', 'layout', 'left-circle', 'left-square', 'like', 'mac-command', 'linkedin', 'lock', 'mail', 'medium-circle', 'medicine-box', 'medium-square', 'meh', 'message', 'merge', 'minus-square', 'mobile', 'money-collect', 'minus-circle', 'muted', 'notification', 'open-a-i', 'moon', 'pause-circle', 'phone', 'picture', 'pinterest', 'pie-chart', 'play-square', 'play-circle', 'pay-circle', 'plus-circle', 'plus-square', 'pound-circle', 'printer', 'project', 'product', 'profile', 'qq-circle', 'pushpin', 'qq-square', 'property-safety', 'read', 'question-circle', 'reconciliation', 'reddit-circle', 'red-envelope', 'reddit-square', 'rest', 'right-circle', 'safety-certificate', 'robot', 'right-square', 'schedule', 'security-scan', 'setting', 'save', 'shop', 'shopping', 'signature', 'sketch-circle', 'sketch-square', 'signal', 'skype', 'rocket', 'sliders', 'slack-circle', 'slack-square', 'smile', 'snippets', 'skin', 'spotify', 'sound', 'star', 'step-backward', 'stop', 'step-forward', 'sun', 'switcher', 'tag', 'tablet', 'tags', 'taobao-circle', 'thunderbolt', 'tool', 'taobao-square', 'trademark-circle', 'tik-tok', 'twitch', 'trophy', 'truck', 'twitter-square', 'twitter-circle', 'unlock', 'up-circle', 'up-square', 'usb', 'video-camera', 'wallet', 'warning', 'wechat', 'weibo-square', 'weibo-circle', 'windows', 'x', 'wechat-work', 'yahoo', 'youtube', 'yuque', 'zhihu-circle', 'zhihu-square'
    ],
    outline: [
        'aim', 'alert', 'account-book', 'align-left', 'align-center', 'align-right', 'alibaba', 'alipay-circle', 'aliyun', 'aliwangwang', 'amazon', 'ant-cloud', 'android', 'apartment', 'ant-design', 'apple', 'appstore-add', 'appstore', 'area-chart', 'arrow-left', 'alipay', 'api', 'arrow-right', 'arrows-alt', 'arrow-up', 'audio-muted', 'arrow-down', 'audio', 'audit', 'backward', 'baidu', 'bank', 'bars', 'barcode', 'behance', 'bell', 'behance-square', 'bg-colors', 'bilibili', 'block', 'border-inner', 'book', 'bold', 'border-left', 'border-outer', 'border-top', 'border', 'border-horizontal', 'border-bottom', 'border-right', 'border-verticle', 'borderless-table', 'box-plot', 'build', 'branches', 'calculator', 'calendar', 'bar-chart', 'bulb', 'camera', 'car', 'bug', 'caret-left', 'carry-out', 'caret-right', 'caret-down', 'check-circle', 'check-square', 'check', 'caret-up', 'chrome', 'ci-circle', 'ci', 'close-circle', 'clear', 'clock-circle', 'close', 'cloud-sync', 'cloud', 'cloud-server', 'cloud-download', 'close-square', 'cloud-upload', 'cluster', 'code-sandbox', 'column-height', 'compass', 'code', 'codepen-circle', 'coffee', 'codepen', 'column-width', 'contacts', 'comment', 'container', 'compress', 'console-sql', 'copyright-circle', 'control', 'copyright', 'crown', 'dash', 'customer-service', 'delete-column', 'delete', 'dashboard', 'delete-row', 'desktop', 'deployment-unit', 'credit-card', 'delivered-procedure', 'database', 'diff', 'disconnect', 'dingding', 'copy', 'dingtalk', 'discord', 'dislike', 'docker', 'dollar', 'dot-net', 'double-left', 'down-circle', 'dot-chart', 'down-square', 'dribbble', 'drag', 'download', 'dribbble-square', 'dropbox', 'edit', 'double-right', 'euro-circle', 'environment', 'dollar-circle', 'enter', 'down', 'euro', 'ellipsis', 'exception', 'exclamation', 'expand-alt', 'experiment', 'export', 'exclamation-circle', 'expand', 'eye', 'fast-backward', 'fast-forward', 'fall', 'field-string', 'field-number', 'file-add', 'facebook', 'field-binary', 'field-time', 'file-exclamation', 'file-gif', 'file-excel', 'file-image', 'eye-invisible', 'file-markdown', 'file-jpg', 'file-pdf', 'file', 'file-search', 'file-protect', 'file-sync', 'file-ppt', 'file-word', 'file-text', 'file-unknown', 'file-zip', 'file-done', 'fire', 'filter', 'flag', 'folder-add', 'folder', 'folder-open', 'font-colors', 'format-painter', 'form', 'font-size', 'forward', 'frown', 'folder-view', 'fullscreen-exit', 'fullscreen', 'function', 'funnel-plot', 'fund-projection-screen', 'gif', 'fund-view', 'fund', 'gateway', 'gift', 'fork', 'github', 'global', 'google', 'gitlab', 'hdd', 'group', 'harmony-o-s', 'gold', 'highlight', 'google-plus', 'holder', 'heart', 'heat-map', 'hourglass', 'history', 'html5', 'home', 'ie', 'inbox', 'idcard', 'info', 'info-circle', 'insert-row-above', 'insert-row-right', 'insert-row-below', 'insurance', 'interaction', 'insert-row-left', 'issues-close', 'italic', 'java-script', 'java', 'key', 'import', 'layout', 'laptop', 'kubernetes', 'left-circle', 'left-square', 'left', 'line-height', 'line', 'like', 'instagram', 'link', 'loading-3-quarters', 'linux', 'mac-command', 'line-chart', 'loading', 'logout', 'login', 'linkedin', 'lock', 'medicine-box', 'mail', 'man', 'medium', 'meh', 'menu-fold', 'menu', 'menu-unfold', 'merge', 'merge-cells', 'message', 'medium-workmark', 'minus-circle', 'minus-square', 'mobile', 'money-collect', 'monitor', 'muted', 'minus', 'moon', 'node-collapse', 'node-index', 'node-expand', 'more', 'paper-clip', 'notification', 'one-to-one', 'partition', 'ordered-list', 'pause-circle', 'open-a-i', 'pause', 'percentage', 'phone', 'picture', 'number', 'pic-center', 'pie-chart', 'pic-right', 'pinterest', 'play-circle', 'pic-left', 'pay-circle', 'plus-square', 'poweroff', 'pound', 'profile', 'printer', 'product', 'property-safety', 'project', 'pull-request', 'python', 'qrcode', 'qq', 'question', 'pushpin', 'radar-chart', 'question-circle', 'radius-bottomleft', 'plus-circle', 'radius-setting', 'radius-bottomright', 'radius-upleft', 'read', 'reconciliation', 'play-square', 'red-envelope', 'radius-upright', 'pound-circle', 'plus', 'rest', 'right-circle', 'reddit', 'right', 'reload', 'redo', 'retweet', 'right-square', 'rise', 'robot', 'rollback', 'rocket', 'rotate-right', 'ruby', 'safety-certificate', 'safety', 'schedule', 'search', 'send', 'select', 'security-scan', 'shake', 'share-alt', 'scan', 'save', 'shop', 'shopping-cart', 'shrink', 'shopping', 'setting', 'scissor', 'signature', 'sisternode', 'skype', 'rotate-left', 'slack-square', 'skin', 'slack', 'sliders', 'snippets', 'solution', 'sort-ascending', 'smile', 'small-dash', 'sketch', 'sort-descending', 'sound', 'star', 'spotify', 'split-cells', 'stock', 'stop', 'strikethrough', 'step-backward', 'sun', 'swap-left', 'swap-right', 'step-forward', 'subnode', 'switcher', 'table', 'tablet', 'sync', 'swap', 'tag', 'tags', 'taobao', 'thunderbolt', 'taobao-circle', 'team', 'to-top', 'tik-tok', 'tool', 'trademark', 'translation', 'trademark-circle', 'transaction', 'trophy', 'undo', 'truck', 'ungroup', 'underline', 'unordered-list', 'unlock', 'twitter', 'up-circle', 'twitch', 'up', 'usb', 'user-add', 'user-delete', 'up-square', 'user-switch', 'vertical-align-middle', 'verified', 'upload', 'user', 'usergroup-delete', 'vertical-left', 'usergroup-add', 'wallet', 'video-camera-add', 'vertical-align-bottom', 'vertical-right', 'warning', 'wechat', 'video-camera', 'weibo-circle', 'vertical-align-top', 'weibo-square', 'wechat-work', 'wifi', 'windows', 'whats-app', 'x', 'woman', 'yuque', 'weibo', 'zhihu', 'youtube', 'yahoo', 'zoom-out', 'zoom-in'
    ],
    twotone: [
        'account-book', 'alert', 'api', 'appstore', 'audio', 'bank', 'bell', 'book', 'box-plot', 'bug', 'build', 'bulb', 'calculator', 'car', 'camera', 'calendar', 'check-circle', 'check-square', 'carry-out', 'ci-circle', 'clock-circle', 'ci', 'close-circle', 'close-square', 'cloud', 'code', 'contacts', 'compass', 'container', 'copyright', 'copy', 'credit-card', 'copyright-circle', 'control', 'customer-service', 'dashboard', 'crown', 'database', 'delete', 'diff', 'dollar-circle', 'dislike', 'down-square', 'down-circle', 'dollar', 'edit', 'euro', 'exclamation-circle', 'experiment', 'euro-circle', 'environment', 'eye-invisible', 'eye', 'file-add', 'file-image', 'file-exclamation', 'file-excel', 'file-pdf', 'file-ppt', 'file-markdown', 'file', 'file-text', 'file-unknown', 'file-zip', 'file-word', 'flag', 'fire', 'folder-add', 'filter', 'folder', 'fund', 'funnel-plot', 'folder-open', 'frown', 'gift', 'gold', 'hdd', 'heart', 'highlight', 'home', 'hourglass', 'idcard', 'insurance', 'info-circle', 'interaction', 'html5', 'left-square', 'layout', 'like', 'lock', 'mail', 'medicine-box', 'meh', 'message', 'minus-circle', 'minus-square', 'money-collect', 'mobile', 'left-circle', 'notification', 'pause-circle', 'phone', 'picture', 'play-circle', 'play-square', 'pie-chart', 'plus-square', 'plus-circle', 'pound-circle', 'printer', 'project', 'profile', 'property-safety', 'pushpin', 'question-circle', 'reconciliation', 'red-envelope', 'right-square', 'rest', 'right-circle', 'rocket', 'safety-certificate', 'save', 'schedule', 'security-scan', 'setting', 'shop', 'shopping', 'skin', 'sliders', 'smile', 'sound', 'snippets', 'stop', 'star', 'switcher', 'tablet', 'tag', 'tags', 'thunderbolt', 'trademark-circle', 'trophy', 'tool', 'up-square', 'unlock', 'up-circle', 'usb', 'video-camera', 'warning', 'wallet'
    ]
};

/**
 * Generated bundle index. Do not edit.
 */

export { ANT_ICONS, ANT_ICON_ANGULAR_CONSOLE_PREFIX, DynamicLoadingTimeoutError, HttpModuleNotImport, IconDirective, IconNotFoundError, IconService, NameSpaceIsNotSpecifyError, SVGTagNotFoundError, UrlNotSafeError, alreadyHasAThemeSuffix, cloneSVG, error, getIconDefinitionFromAbbr, getNameAndNamespace, getSecondaryColor, hasNamespace, isIconDefinition, manifest, mapAbbrToTheme, provideAntIcons, replaceFillColor, warn, withSuffix, withSuffixAndColor };
//# sourceMappingURL=ant-design-icons-angular.mjs.map
