{"version":3,"file":"_localize-chunk.mjs","sources":["../../../../../k8-fastbuild-ST-fdfa778d11ba/bin/packages/localize/src/utils/src/constants.ts","../../../../../k8-fastbuild-ST-fdfa778d11ba/bin/packages/compiler/src/i18n/digest.ts","../../../../../k8-fastbuild-ST-fdfa778d11ba/bin/packages/localize/src/utils/src/messages.ts","../../../../../k8-fastbuild-ST-fdfa778d11ba/bin/packages/localize/src/localize/src/localize.ts"],"sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\n/**\n * The character used to mark the start and end of a \"block\" in a `$localize` tagged string.\n * A block can indicate metadata about the message or specify a name of a placeholder for a\n * substitution expressions.\n *\n * For example:\n *\n * ```ts\n * $localize`Hello, ${title}:title:!`;\n * $localize`:meaning|description@@id:source message text`;\n * ```\n */\nexport const BLOCK_MARKER = ':';\n\n/**\n * The marker used to separate a message's \"meaning\" from its \"description\" in a metadata block.\n *\n * For example:\n *\n * ```ts\n * $localize `:correct|Indicates that the user got the answer correct: Right!`;\n * $localize `:movement|Button label for moving to the right: Right!`;\n * ```\n */\nexport const MEANING_SEPARATOR = '|';\n\n/**\n * The marker used to separate a message's custom \"id\" from its \"description\" in a metadata block.\n *\n * For example:\n *\n * ```ts\n * $localize `:A welcome message on the home page@@myApp-homepage-welcome: Welcome!`;\n * ```\n */\nexport const ID_SEPARATOR = '@@';\n\n/**\n * The marker used to separate legacy message ids from the rest of a metadata block.\n *\n * For example:\n *\n * ```ts\n * $localize `:@@custom-id␟2df64767cd895a8fabe3e18b94b5b6b6f9e2e3f0: Welcome!`;\n * ```\n *\n * Note that this character is the \"symbol for the unit separator\" (␟) not the \"unit separator\n * character\" itself, since that has no visual representation. See https://graphemica.com/%E2%90%9F.\n *\n * Here is some background for the original \"unit separator character\":\n * https://stackoverflow.com/questions/8695118/whats-the-file-group-record-unit-separator-control-characters-and-its-usage\n */\nexport const LEGACY_ID_INDICATOR = '\\u241F';\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {Byte} from '../util';\n\nimport * as i18n from './i18n_ast';\n\n/**\n * A lazily created TextEncoder instance for converting strings into UTF-8 bytes\n */\nlet textEncoder: TextEncoder | undefined;\n\n/**\n * Return the message id or compute it using the XLIFF1 digest.\n */\nexport function digest(message: i18n.Message): string {\n  return message.id || computeDigest(message);\n}\n\n/**\n * Compute the message id using the XLIFF1 digest.\n */\nexport function computeDigest(message: i18n.Message): string {\n  return sha1(serializeNodes(message.nodes).join('') + `[${message.meaning}]`);\n}\n\n/**\n * Return the message id or compute it using the XLIFF2/XMB/$localize digest.\n */\nexport function decimalDigest(message: i18n.Message): string {\n  return message.id || computeDecimalDigest(message);\n}\n\n/**\n * Compute the message id using the XLIFF2/XMB/$localize digest.\n */\nexport function computeDecimalDigest(message: i18n.Message): string {\n  const visitor = new _SerializerIgnoreIcuExpVisitor();\n  const parts = message.nodes.map((a) => a.visit(visitor, null));\n  return computeMsgId(parts.join(''), message.meaning);\n}\n\n/**\n * Serialize the i18n ast to something xml-like in order to generate an UID.\n *\n * The visitor is also used in the i18n parser tests\n *\n * @internal\n */\nclass _SerializerVisitor implements i18n.Visitor {\n  visitText(text: i18n.Text, context: any): any {\n    return text.value;\n  }\n\n  visitContainer(container: i18n.Container, context: any): any {\n    return `[${container.children.map((child) => child.visit(this)).join(', ')}]`;\n  }\n\n  visitIcu(icu: i18n.Icu, context: any): any {\n    const strCases = Object.keys(icu.cases).map(\n      (k: string) => `${k} {${icu.cases[k].visit(this)}}`,\n    );\n    return `{${icu.expression}, ${icu.type}, ${strCases.join(', ')}}`;\n  }\n\n  visitTagPlaceholder(ph: i18n.TagPlaceholder, context: any): any {\n    return ph.isVoid\n      ? `<ph tag name=\"${ph.startName}\"/>`\n      : `<ph tag name=\"${ph.startName}\">${ph.children\n          .map((child) => child.visit(this))\n          .join(', ')}</ph name=\"${ph.closeName}\">`;\n  }\n\n  visitPlaceholder(ph: i18n.Placeholder, context: any): any {\n    return ph.value ? `<ph name=\"${ph.name}\">${ph.value}</ph>` : `<ph name=\"${ph.name}\"/>`;\n  }\n\n  visitIcuPlaceholder(ph: i18n.IcuPlaceholder, context?: any): any {\n    return `<ph icu name=\"${ph.name}\">${ph.value.visit(this)}</ph>`;\n  }\n\n  visitBlockPlaceholder(ph: i18n.BlockPlaceholder, context: any): any {\n    return `<ph block name=\"${ph.startName}\">${ph.children\n      .map((child) => child.visit(this))\n      .join(', ')}</ph name=\"${ph.closeName}\">`;\n  }\n}\n\nconst serializerVisitor = new _SerializerVisitor();\n\nexport function serializeNodes(nodes: i18n.Node[]): string[] {\n  return nodes.map((a) => a.visit(serializerVisitor, null));\n}\n\n/**\n * Serialize the i18n ast to something xml-like in order to generate an UID.\n *\n * Ignore the ICU expressions so that message IDs stays identical if only the expression changes.\n *\n * @internal\n */\nclass _SerializerIgnoreIcuExpVisitor extends _SerializerVisitor {\n  override visitIcu(icu: i18n.Icu): string {\n    let strCases = Object.keys(icu.cases).map((k: string) => `${k} {${icu.cases[k].visit(this)}}`);\n    // Do not take the expression into account\n    return `{${icu.type}, ${strCases.join(', ')}}`;\n  }\n}\n\n/**\n * Compute the SHA1 of the given string\n *\n * see https://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf\n *\n * WARNING: this function has not been designed not tested with security in mind.\n *          DO NOT USE IT IN A SECURITY SENSITIVE CONTEXT.\n */\nexport function sha1(str: string): string {\n  textEncoder ??= new TextEncoder();\n  const utf8 = [...textEncoder.encode(str)];\n  const words32 = bytesToWords32(utf8, Endian.Big);\n  const len = utf8.length * 8;\n\n  const w = new Uint32Array(80);\n  let a = 0x67452301,\n    b = 0xefcdab89,\n    c = 0x98badcfe,\n    d = 0x10325476,\n    e = 0xc3d2e1f0;\n\n  words32[len >> 5] |= 0x80 << (24 - (len % 32));\n  words32[(((len + 64) >> 9) << 4) + 15] = len;\n\n  for (let i = 0; i < words32.length; i += 16) {\n    const h0 = a,\n      h1 = b,\n      h2 = c,\n      h3 = d,\n      h4 = e;\n\n    for (let j = 0; j < 80; j++) {\n      if (j < 16) {\n        w[j] = words32[i + j];\n      } else {\n        w[j] = rol32(w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16], 1);\n      }\n\n      const fkVal = fk(j, b, c, d);\n      const f = fkVal[0];\n      const k = fkVal[1];\n      const temp = [rol32(a, 5), f, e, k, w[j]].reduce(add32);\n      e = d;\n      d = c;\n      c = rol32(b, 30);\n      b = a;\n      a = temp;\n    }\n    a = add32(a, h0);\n    b = add32(b, h1);\n    c = add32(c, h2);\n    d = add32(d, h3);\n    e = add32(e, h4);\n  }\n\n  // Convert the output parts to a 160-bit hexadecimal string\n  return toHexU32(a) + toHexU32(b) + toHexU32(c) + toHexU32(d) + toHexU32(e);\n}\n\n/**\n * Convert and format a number as a string representing a 32-bit unsigned hexadecimal number.\n * @param value The value to format as a string.\n * @returns A hexadecimal string representing the value.\n */\nfunction toHexU32(value: number): string {\n  // unsigned right shift of zero ensures an unsigned 32-bit number\n  return (value >>> 0).toString(16).padStart(8, '0');\n}\n\nfunction fk(index: number, b: number, c: number, d: number): [number, number] {\n  if (index < 20) {\n    return [(b & c) | (~b & d), 0x5a827999];\n  }\n\n  if (index < 40) {\n    return [b ^ c ^ d, 0x6ed9eba1];\n  }\n\n  if (index < 60) {\n    return [(b & c) | (b & d) | (c & d), 0x8f1bbcdc];\n  }\n\n  return [b ^ c ^ d, 0xca62c1d6];\n}\n\n/**\n * Compute the fingerprint of the given string\n *\n * The output is 64 bit number encoded as a decimal string\n *\n * based on:\n * https://github.com/google/closure-compiler/blob/master/src/com/google/javascript/jscomp/GoogleJsMessageIdGenerator.java\n */\nexport function fingerprint(str: string): bigint {\n  textEncoder ??= new TextEncoder();\n  const utf8 = textEncoder.encode(str);\n  const view = new DataView(utf8.buffer, utf8.byteOffset, utf8.byteLength);\n\n  let hi = hash32(view, utf8.length, 0);\n  let lo = hash32(view, utf8.length, 102072);\n\n  if (hi == 0 && (lo == 0 || lo == 1)) {\n    hi = hi ^ 0x130f9bef;\n    lo = lo ^ -0x6b5f56d8;\n  }\n\n  return (BigInt.asUintN(32, BigInt(hi)) << BigInt(32)) | BigInt.asUintN(32, BigInt(lo));\n}\n\nexport function computeMsgId(msg: string, meaning: string = ''): string {\n  let msgFingerprint = fingerprint(msg);\n\n  if (meaning) {\n    // Rotate the 64-bit message fingerprint one bit to the left and then add the meaning\n    // fingerprint.\n    msgFingerprint =\n      BigInt.asUintN(64, msgFingerprint << BigInt(1)) |\n      ((msgFingerprint >> BigInt(63)) & BigInt(1));\n    msgFingerprint += fingerprint(meaning);\n  }\n\n  return BigInt.asUintN(63, msgFingerprint).toString();\n}\n\nfunction hash32(view: DataView, length: number, c: number): number {\n  let a = 0x9e3779b9,\n    b = 0x9e3779b9;\n  let index = 0;\n\n  const end = length - 12;\n  for (; index <= end; index += 12) {\n    a += view.getUint32(index, true);\n    b += view.getUint32(index + 4, true);\n    c += view.getUint32(index + 8, true);\n    const res = mix(a, b, c);\n    ((a = res[0]), (b = res[1]), (c = res[2]));\n  }\n\n  const remainder = length - index;\n\n  // the first byte of c is reserved for the length\n  c += length;\n\n  if (remainder >= 4) {\n    a += view.getUint32(index, true);\n    index += 4;\n\n    if (remainder >= 8) {\n      b += view.getUint32(index, true);\n      index += 4;\n\n      // Partial 32-bit word for c\n      if (remainder >= 9) {\n        c += view.getUint8(index++) << 8;\n      }\n      if (remainder >= 10) {\n        c += view.getUint8(index++) << 16;\n      }\n      if (remainder === 11) {\n        c += view.getUint8(index++) << 24;\n      }\n    } else {\n      // Partial 32-bit word for b\n      if (remainder >= 5) {\n        b += view.getUint8(index++);\n      }\n      if (remainder >= 6) {\n        b += view.getUint8(index++) << 8;\n      }\n      if (remainder === 7) {\n        b += view.getUint8(index++) << 16;\n      }\n    }\n  } else {\n    // Partial 32-bit word for a\n    if (remainder >= 1) {\n      a += view.getUint8(index++);\n    }\n    if (remainder >= 2) {\n      a += view.getUint8(index++) << 8;\n    }\n    if (remainder === 3) {\n      a += view.getUint8(index++) << 16;\n    }\n  }\n\n  return mix(a, b, c)[2];\n}\n\nfunction mix(a: number, b: number, c: number): [number, number, number] {\n  a -= b;\n  a -= c;\n  a ^= c >>> 13;\n  b -= c;\n  b -= a;\n  b ^= a << 8;\n  c -= a;\n  c -= b;\n  c ^= b >>> 13;\n  a -= b;\n  a -= c;\n  a ^= c >>> 12;\n  b -= c;\n  b -= a;\n  b ^= a << 16;\n  c -= a;\n  c -= b;\n  c ^= b >>> 5;\n  a -= b;\n  a -= c;\n  a ^= c >>> 3;\n  b -= c;\n  b -= a;\n  b ^= a << 10;\n  c -= a;\n  c -= b;\n  c ^= b >>> 15;\n  return [a, b, c];\n}\n\n// Utils\n\nenum Endian {\n  Little,\n  Big,\n}\n\nfunction add32(a: number, b: number): number {\n  return add32to64(a, b)[1];\n}\n\nfunction add32to64(a: number, b: number): [number, number] {\n  const low = (a & 0xffff) + (b & 0xffff);\n  const high = (a >>> 16) + (b >>> 16) + (low >>> 16);\n  return [high >>> 16, (high << 16) | (low & 0xffff)];\n}\n\n// Rotate a 32b number left `count` position\nfunction rol32(a: number, count: number): number {\n  return (a << count) | (a >>> (32 - count));\n}\n\nfunction bytesToWords32(bytes: Byte[], endian: Endian): number[] {\n  const size = (bytes.length + 3) >>> 2;\n  const words32 = [];\n\n  for (let i = 0; i < size; i++) {\n    words32[i] = wordAt(bytes, i * 4, endian);\n  }\n\n  return words32;\n}\n\nfunction byteAt(bytes: Byte[], index: number): Byte {\n  return index >= bytes.length ? 0 : bytes[index];\n}\n\nfunction wordAt(bytes: Byte[], index: number, endian: Endian): number {\n  let word = 0;\n  if (endian === Endian.Big) {\n    for (let i = 0; i < 4; i++) {\n      word += byteAt(bytes, index + i) << (24 - 8 * i);\n    }\n  } else {\n    for (let i = 0; i < 4; i++) {\n      word += byteAt(bytes, index + i) << (8 * i);\n    }\n  }\n  return word;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n// This module specifier is intentionally a relative path to allow bundling the code directly\n// into the package.\n// @ng_package: ignore-cross-repo-import\nimport {computeMsgId} from '../../../../compiler/src/i18n/digest';\n\nimport {BLOCK_MARKER, ID_SEPARATOR, LEGACY_ID_INDICATOR, MEANING_SEPARATOR} from './constants';\n\n/**\n * Re-export this helper function so that users of `@angular/localize` don't need to actively import\n * from `@angular/compiler`.\n */\nexport {computeMsgId};\n\n/**\n * A string containing a translation source message.\n *\n * I.E. the message that indicates what will be translated from.\n *\n * Uses `{$placeholder-name}` to indicate a placeholder.\n */\nexport type SourceMessage = string;\n\n/**\n * A string containing a translation target message.\n *\n * I.E. the message that indicates what will be translated to.\n *\n * Uses `{$placeholder-name}` to indicate a placeholder.\n *\n * @publicApi\n */\nexport type TargetMessage = string;\n\n/**\n * A string that uniquely identifies a message, to be used for matching translations.\n *\n * @publicApi\n */\nexport type MessageId = string;\n\n/**\n * Declares a copy of the `AbsoluteFsPath` branded type in `@angular/compiler-cli` to avoid an\n * import into `@angular/compiler-cli`. The compiler-cli's declaration files are not necessarily\n * compatible with web environments that use `@angular/localize`, and would inadvertently include\n * `typescript` declaration files in any compilation unit that uses `@angular/localize` (which\n * increases parsing time and memory usage during builds) using a default import that only\n * type-checks when `allowSyntheticDefaultImports` is enabled.\n *\n * @see https://github.com/angular/angular/issues/45179\n */\ntype AbsoluteFsPathLocalizeCopy = string & {_brand: 'AbsoluteFsPath'};\n\n/**\n * The location of the message in the source file.\n *\n * The `line` and `column` values for the `start` and `end` properties are zero-based.\n */\nexport interface SourceLocation {\n  start: {line: number; column: number};\n  end: {line: number; column: number};\n  file: AbsoluteFsPathLocalizeCopy;\n  text?: string;\n}\n\n/**\n * Additional information that can be associated with a message.\n */\nexport interface MessageMetadata {\n  /**\n   * A human readable rendering of the message\n   */\n  text: string;\n  /**\n   * Legacy message ids, if provided.\n   *\n   * In legacy message formats the message id can only be computed directly from the original\n   * template source.\n   *\n   * Since this information is not available in `$localize` calls, the legacy message ids may be\n   * attached by the compiler to the `$localize` metablock so it can be used if needed at the point\n   * of translation if the translations are encoded using the legacy message id.\n   */\n  legacyIds?: string[];\n  /**\n   * The id of the `message` if a custom one was specified explicitly.\n   *\n   * This id overrides any computed or legacy ids.\n   */\n  customId?: string;\n  /**\n   * The meaning of the `message`, used to distinguish identical `messageString`s.\n   */\n  meaning?: string;\n  /**\n   * The description of the `message`, used to aid translation.\n   */\n  description?: string;\n  /**\n   * The location of the message in the source.\n   */\n  location?: SourceLocation;\n}\n\n/**\n * Information parsed from a `$localize` tagged string that is used to translate it.\n *\n * For example:\n *\n * ```ts\n * const name = 'Jo Bloggs';\n * $localize`Hello ${name}:title@@ID:!`;\n * ```\n *\n * May be parsed into:\n *\n * ```ts\n * {\n *   id: '6998194507597730591',\n *   substitutions: { title: 'Jo Bloggs' },\n *   messageString: 'Hello {$title}!',\n *   placeholderNames: ['title'],\n *   associatedMessageIds: { title: 'ID' },\n * }\n * ```\n */\nexport interface ParsedMessage extends MessageMetadata {\n  /**\n   * The key used to look up the appropriate translation target.\n   */\n  id: MessageId;\n  /**\n   * A mapping of placeholder names to substitution values.\n   */\n  substitutions: Record<string, any>;\n  /**\n   * An optional mapping of placeholder names to associated MessageIds.\n   * This can be used to match ICU placeholders to the message that contains the ICU.\n   */\n  associatedMessageIds?: Record<string, MessageId>;\n  /**\n   * An optional mapping of placeholder names to source locations\n   */\n  substitutionLocations?: Record<string, SourceLocation | undefined>;\n  /**\n   * The static parts of the message.\n   */\n  messageParts: string[];\n  /**\n   * An optional mapping of message parts to source locations\n   */\n  messagePartLocations?: (SourceLocation | undefined)[];\n  /**\n   * The names of the placeholders that will be replaced with substitutions.\n   */\n  placeholderNames: string[];\n}\n\n/**\n * Parse a `$localize` tagged string into a structure that can be used for translation or\n * extraction.\n *\n * See `ParsedMessage` for an example.\n */\nexport function parseMessage(\n  messageParts: TemplateStringsArray,\n  expressions?: readonly any[],\n  location?: SourceLocation,\n  messagePartLocations?: (SourceLocation | undefined)[],\n  expressionLocations: (SourceLocation | undefined)[] = [],\n): ParsedMessage {\n  const substitutions: {[placeholderName: string]: any} = {};\n  const substitutionLocations: {[placeholderName: string]: SourceLocation | undefined} = {};\n  const associatedMessageIds: {[placeholderName: string]: MessageId} = {};\n  const metadata = parseMetadata(messageParts[0], messageParts.raw[0]);\n  const cleanedMessageParts: string[] = [metadata.text];\n  const placeholderNames: string[] = [];\n  let messageString = metadata.text;\n  for (let i = 1; i < messageParts.length; i++) {\n    const {\n      messagePart,\n      placeholderName = computePlaceholderName(i),\n      associatedMessageId,\n    } = parsePlaceholder(messageParts[i], messageParts.raw[i]);\n    messageString += `{$${placeholderName}}${messagePart}`;\n    if (expressions !== undefined) {\n      substitutions[placeholderName] = expressions[i - 1];\n      substitutionLocations[placeholderName] = expressionLocations[i - 1];\n    }\n    placeholderNames.push(placeholderName);\n    if (associatedMessageId !== undefined) {\n      associatedMessageIds[placeholderName] = associatedMessageId;\n    }\n    cleanedMessageParts.push(messagePart);\n  }\n  const messageId = metadata.customId || computeMsgId(messageString, metadata.meaning || '');\n  const legacyIds = metadata.legacyIds ? metadata.legacyIds.filter((id) => id !== messageId) : [];\n  return {\n    id: messageId,\n    legacyIds,\n    substitutions,\n    substitutionLocations,\n    text: messageString,\n    customId: metadata.customId,\n    meaning: metadata.meaning || '',\n    description: metadata.description || '',\n    messageParts: cleanedMessageParts,\n    messagePartLocations,\n    placeholderNames,\n    associatedMessageIds,\n    location,\n  };\n}\n\n/**\n * Parse the given message part (`cooked` + `raw`) to extract the message metadata from the text.\n *\n * If the message part has a metadata block this function will extract the `meaning`,\n * `description`, `customId` and `legacyId` (if provided) from the block. These metadata properties\n * are serialized in the string delimited by `|`, `@@` and `␟` respectively.\n *\n * (Note that `␟` is the `LEGACY_ID_INDICATOR` - see `constants.ts`.)\n *\n * For example:\n *\n * ```ts\n * `:meaning|description@@custom-id:`\n * `:meaning|@@custom-id:`\n * `:meaning|description:`\n * `:description@@custom-id:`\n * `:meaning|:`\n * `:description:`\n * `:@@custom-id:`\n * `:meaning|description@@custom-id␟legacy-id-1␟legacy-id-2:`\n * ```\n *\n * @param cooked The cooked version of the message part to parse.\n * @param raw The raw version of the message part to parse.\n * @returns A object containing any metadata that was parsed from the message part.\n */\nexport function parseMetadata(cooked: string, raw: string): MessageMetadata {\n  const {text: messageString, block} = splitBlock(cooked, raw);\n  if (block === undefined) {\n    return {text: messageString};\n  } else {\n    const [meaningDescAndId, ...legacyIds] = block.split(LEGACY_ID_INDICATOR);\n    const [meaningAndDesc, customId] = meaningDescAndId.split(ID_SEPARATOR, 2);\n    let [meaning, description]: (string | undefined)[] = meaningAndDesc.split(MEANING_SEPARATOR, 2);\n    if (description === undefined) {\n      description = meaning;\n      meaning = undefined;\n    }\n    if (description === '') {\n      description = undefined;\n    }\n    return {text: messageString, meaning, description, customId, legacyIds};\n  }\n}\n\n/**\n * Parse the given message part (`cooked` + `raw`) to extract any placeholder metadata from the\n * text.\n *\n * If the message part has a metadata block this function will extract the `placeholderName` and\n * `associatedMessageId` (if provided) from the block.\n *\n * These metadata properties are serialized in the string delimited by `@@`.\n *\n * For example:\n *\n * ```ts\n * `:placeholder-name@@associated-id:`\n * ```\n *\n * @param cooked The cooked version of the message part to parse.\n * @param raw The raw version of the message part to parse.\n * @returns A object containing the metadata (`placeholderName` and `associatedMessageId`) of the\n *     preceding placeholder, along with the static text that follows.\n */\nexport function parsePlaceholder(\n  cooked: string,\n  raw: string,\n): {messagePart: string; placeholderName?: string; associatedMessageId?: string} {\n  const {text: messagePart, block} = splitBlock(cooked, raw);\n  if (block === undefined) {\n    return {messagePart};\n  } else {\n    const [placeholderName, associatedMessageId] = block.split(ID_SEPARATOR);\n    return {messagePart, placeholderName, associatedMessageId};\n  }\n}\n\n/**\n * Split a message part (`cooked` + `raw`) into an optional delimited \"block\" off the front and the\n * rest of the text of the message part.\n *\n * Blocks appear at the start of message parts. They are delimited by a colon `:` character at the\n * start and end of the block.\n *\n * If the block is in the first message part then it will be metadata about the whole message:\n * meaning, description, id.  Otherwise it will be metadata about the immediately preceding\n * substitution: placeholder name.\n *\n * Since blocks are optional, it is possible that the content of a message block actually starts\n * with a block marker. In this case the marker must be escaped `\\:`.\n *\n * @param cooked The cooked version of the message part to parse.\n * @param raw The raw version of the message part to parse.\n * @returns An object containing the `text` of the message part and the text of the `block`, if it\n * exists.\n * @throws an error if the `block` is unterminated\n */\nexport function splitBlock(cooked: string, raw: string): {text: string; block?: string} {\n  if (raw.charAt(0) !== BLOCK_MARKER) {\n    return {text: cooked};\n  } else {\n    const endOfBlock = findEndOfBlock(cooked, raw);\n    return {\n      block: cooked.substring(1, endOfBlock),\n      text: cooked.substring(endOfBlock + 1),\n    };\n  }\n}\n\nfunction computePlaceholderName(index: number) {\n  return index === 1 ? 'PH' : `PH_${index - 1}`;\n}\n\n/**\n * Find the end of a \"marked block\" indicated by the first non-escaped colon.\n *\n * @param cooked The cooked string (where escaped chars have been processed)\n * @param raw The raw string (where escape sequences are still in place)\n *\n * @returns the index of the end of block marker\n * @throws an error if the block is unterminated\n */\nexport function findEndOfBlock(cooked: string, raw: string): number {\n  for (let cookedIndex = 1, rawIndex = 1; cookedIndex < cooked.length; cookedIndex++, rawIndex++) {\n    if (raw[rawIndex] === '\\\\') {\n      rawIndex++;\n    } else if (cooked[cookedIndex] === BLOCK_MARKER) {\n      return cookedIndex;\n    }\n  }\n  throw new Error(`Unterminated $localize metadata block in \"${raw}\".`);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {findEndOfBlock} from '../../utils';\n\n/** @docs-private */\nexport interface LocalizeFn {\n  (messageParts: TemplateStringsArray, ...expressions: readonly any[]): string;\n\n  /**\n   * A function that converts an input \"message with expressions\" into a translated \"message with\n   * expressions\".\n   *\n   * The conversion may be done in place, modifying the array passed to the function, so\n   * don't assume that this has no side-effects.\n   *\n   * The expressions must be passed in since it might be they need to be reordered for\n   * different translations.\n   */\n  translate?: TranslateFn;\n  /**\n   * The current locale of the translated messages.\n   *\n   * The compile-time translation inliner is able to replace the following code:\n   *\n   * ```ts\n   * typeof $localize !== \"undefined\" && $localize.locale\n   * ```\n   *\n   * with a string literal of the current locale. E.g.\n   *\n   * ```\n   * \"fr\"\n   * ```\n   */\n  locale?: string;\n}\n\n/** @docs-private */\nexport interface TranslateFn {\n  (\n    messageParts: TemplateStringsArray,\n    expressions: readonly any[],\n  ): [TemplateStringsArray, readonly any[]];\n}\n\n/**\n * Tag a template literal string for localization.\n *\n * For example:\n *\n * ```ts\n * $localize `some string to localize`\n * ```\n *\n * **Providing meaning, description and id**\n *\n * You can optionally specify one or more of `meaning`, `description` and `id` for a localized\n * string by pre-pending it with a colon delimited block of the form:\n *\n * ```ts\n * $localize`:meaning|description@@id:source message text`;\n *\n * $localize`:meaning|:source message text`;\n * $localize`:description:source message text`;\n * $localize`:@@id:source message text`;\n * ```\n *\n * This format is the same as that used for `i18n` markers in Angular templates. See the\n * [Angular i18n guide](guide/i18n/prepare#mark-text-in-component-template).\n *\n * **Naming placeholders**\n *\n * If the template literal string contains expressions, then the expressions will be automatically\n * associated with placeholder names for you.\n *\n * For example:\n *\n * ```ts\n * $localize `Hi ${name}! There are ${items.length} items.`;\n * ```\n *\n * will generate a message-source of `Hi {$PH}! There are {$PH_1} items`.\n *\n * The recommended practice is to name the placeholder associated with each expression though.\n *\n * Do this by providing the placeholder name wrapped in `:` characters directly after the\n * expression. These placeholder names are stripped out of the rendered localized string.\n *\n * For example, to name the `items.length` expression placeholder `itemCount` you write:\n *\n * ```ts\n * $localize `There are ${items.length}:itemCount: items`;\n * ```\n *\n * **Escaping colon markers**\n *\n * If you need to use a `:` character directly at the start of a tagged string that has no\n * metadata block, or directly after a substitution expression that has no name you must escape\n * the `:` by preceding it with a backslash:\n *\n * For example:\n *\n * ```ts\n * // message has a metadata block so no need to escape colon\n * $localize `:some description::this message starts with a colon (:)`;\n * // no metadata block so the colon must be escaped\n * $localize `\\:this message starts with a colon (:)`;\n * ```\n *\n * ```ts\n * // named substitution so no need to escape colon\n * $localize `${label}:label:: ${}`\n * // anonymous substitution so colon must be escaped\n * $localize `${label}\\: ${}`\n * ```\n *\n * **Processing localized strings:**\n *\n * There are three scenarios:\n *\n * * **compile-time inlining**: the `$localize` tag is transformed at compile time by a\n * transpiler, removing the tag and replacing the template literal string with a translated\n * literal string from a collection of translations provided to the transpilation tool.\n *\n * * **run-time evaluation**: the `$localize` tag is a run-time function that replaces and\n * reorders the parts (static strings and expressions) of the template literal string with strings\n * from a collection of translations loaded at run-time.\n *\n * * **pass-through evaluation**: the `$localize` tag is a run-time function that simply evaluates\n * the original template literal string without applying any translations to the parts. This\n * version is used during development or where there is no need to translate the localized\n * template literals.\n *\n * @param messageParts a collection of the static parts of the template string.\n * @param expressions a collection of the values of each placeholder in the template string.\n * @returns the translated string, with the `messageParts` and `expressions` interleaved together.\n *\n * @publicApi\n */\nexport const $localize: LocalizeFn = function (\n  messageParts: TemplateStringsArray,\n  ...expressions: readonly any[]\n) {\n  if ($localize.translate) {\n    // Don't use array expansion here to avoid the compiler adding `__read()` helper unnecessarily.\n    const translation = $localize.translate(messageParts, expressions);\n    messageParts = translation[0];\n    expressions = translation[1];\n  }\n  let message = stripBlock(messageParts[0], messageParts.raw[0]);\n  for (let i = 1; i < messageParts.length; i++) {\n    message += expressions[i - 1] + stripBlock(messageParts[i], messageParts.raw[i]);\n  }\n  return message;\n};\n\nconst BLOCK_MARKER = ':';\n\n/**\n * Strip a delimited \"block\" from the start of the `messagePart`, if it is found.\n *\n * If a marker character (:) actually appears in the content at the start of a tagged string or\n * after a substitution expression, where a block has not been provided the character must be\n * escaped with a backslash, `\\:`. This function checks for this by looking at the `raw`\n * messagePart, which should still contain the backslash.\n *\n * @param messagePart The cooked message part to process.\n * @param rawMessagePart The raw message part to check.\n * @returns the message part with the placeholder name stripped, if found.\n * @throws an error if the block is unterminated\n */\nfunction stripBlock(messagePart: string, rawMessagePart: string) {\n  return rawMessagePart.charAt(0) === BLOCK_MARKER\n    ? messagePart.substring(findEndOfBlock(messagePart, rawMessagePart) + 1)\n    : messagePart;\n}\n"],"names":["BLOCK_MARKER","MEANING_SEPARATOR","ID_SEPARATOR","LEGACY_ID_INDICATOR","textEncoder","fingerprint","str","TextEncoder","utf8","encode","view","DataView","buffer","byteOffset","byteLength","hi","hash32","length","lo","BigInt","asUintN","computeMsgId","msg","meaning","msgFingerprint","toString","c","a","b","index","end","getUint32","res","mix","remainder","getUint8","Endian","parseMessage","messageParts","expressions","location","messagePartLocations","expressionLocations","substitutions","substitutionLocations","associatedMessageIds","metadata","parseMetadata","raw","cleanedMessageParts","text","placeholderNames","messageString","i","messagePart","placeholderName","computePlaceholderName","associatedMessageId","parsePlaceholder","undefined","push","messageId","customId","legacyIds","filter","id","description","cooked","block","splitBlock","meaningDescAndId","split","meaningAndDesc","charAt","endOfBlock","findEndOfBlock","substring","cookedIndex","rawIndex","Error","$localize","translate","translation","message","stripBlock","rawMessagePart"],"mappings":"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"}