import * as _angular_core from '@angular/core';
import { ElementRef, OnChanges, OnInit, AfterViewInit, TemplateRef, SimpleChanges, InjectionToken } from '@angular/core';
import { ControlValueAccessor } from '@angular/forms';
import { Subject } from 'rxjs';

declare class NgSelectConfig {
    placeholder: string;
    fixedPlaceholder: boolean;
    notFoundText: string;
    typeToSearchText: string;
    addTagText: string;
    loadingText: string;
    clearAllText: string;
    disableVirtualScroll: boolean;
    openOnEnter: boolean;
    appendTo: string;
    bindValue: string;
    bindLabel: string;
    appearance: string;
    clearSearchOnAdd: boolean;
    deselectOnClick: boolean;
    tabFocusOnClear: boolean;
    /**
     * Controls which DOM event is used to detect outside clicks for closing the dropdown.
     * Defaults to 'click'. Set to 'mousedown' to handle early outside interactions
     * (useful when backdrops load on click and would otherwise close the dropdown).
     */
    outsideClickEvent: 'click' | 'mousedown';
    static ɵfac: _angular_core.ɵɵFactoryDeclaration<NgSelectConfig, never>;
    static ɵprov: _angular_core.ɵɵInjectableDeclaration<NgSelectConfig>;
}

interface NgOption {
    [name: string]: any;
    index?: number;
    htmlId?: string;
    selected?: boolean;
    disabled?: boolean;
    marked?: boolean;
    label?: string;
    value?: string | any;
    parent?: NgOption;
    children?: NgOption[];
}
type DropdownPosition = 'top' | 'right' | 'bottom' | 'left' | 'auto';

type SelectionModelFactory = () => SelectionModel;
declare function DefaultSelectionModelFactory(): DefaultSelectionModel;
interface SelectionModel {
    value: NgOption[];
    select(item: NgOption, multiple: boolean, selectableGroupAsModel: boolean): any;
    unselect(item: NgOption, multiple: boolean): any;
    clear(keepDisabled: boolean): any;
}
declare class DefaultSelectionModel implements SelectionModel {
    private _selected;
    get value(): NgOption[];
    select(item: NgOption, multiple: boolean, groupAsModel: boolean): void;
    unselect(item: NgOption, multiple: boolean): void;
    clear(keepDisabled: boolean): void;
    private _setChildrenSelectedState;
    private _removeChildren;
    private _removeParent;
    private _activeChildren;
}

declare class ItemsList {
    private _ngSelect;
    private _selectionModel;
    private _groups;
    constructor(_ngSelect: NgSelectComponent, _selectionModel: SelectionModel);
    private _items;
    get items(): NgOption[];
    private _filteredItems;
    get filteredItems(): NgOption[];
    private _markedIndex;
    get markedIndex(): number;
    get selectedItems(): NgOption[];
    get markedItem(): NgOption;
    get noItemsToSelect(): boolean;
    get maxItemsSelected(): boolean;
    get lastSelectedItem(): NgOption;
    setItems(items: readonly any[]): void;
    select(item: NgOption): void;
    unselect(item: NgOption): void;
    findItem(value: any): NgOption;
    addItem(item: any): NgOption;
    clearSelected(keepDisabled?: boolean): void;
    findByLabel(term: string): NgOption;
    filter(term: string): void;
    resetFilteredItems(): void;
    unmarkItem(): void;
    markNextItem(): void;
    markPreviousItem(): void;
    markItem(item: NgOption): void;
    markSelectedOrDefault(markDefault?: boolean): void;
    resolveNested(option: any, key: string): any;
    mapItem(item: any, index: number): NgOption;
    mapSelectedItems(): void;
    private _showSelected;
    private _hideSelected;
    private _defaultSearchFn;
    private _getNextItemIndex;
    private _stepToItem;
    private _getLastMarkedIndex;
    private _groupBy;
    private _flatten;
}

declare class NgOptionComponent {
    readonly value: _angular_core.InputSignal<any>;
    readonly disabled: _angular_core.InputSignalWithTransform<boolean, unknown>;
    readonly elementRef: ElementRef<any>;
    readonly label: _angular_core.WritableSignal<string>;
    constructor();
    static ɵfac: _angular_core.ɵɵFactoryDeclaration<NgOptionComponent, never>;
    static ɵcmp: _angular_core.ɵɵComponentDeclaration<NgOptionComponent, "ng-option", never, { "value": { "alias": "value"; "required": false; "isSignal": true; }; "disabled": { "alias": "disabled"; "required": false; "isSignal": true; }; }, {}, never, ["*"], true, never>;
}

declare const SELECTION_MODEL_FACTORY: InjectionToken<SelectionModelFactory>;
type AddTagFn = (term: string) => any | Promise<any>;
type CompareWithFn = (a: any, b: any) => boolean;
type GroupValueFn = (key: string | any, children: any[]) => string | any;
declare class NgSelectComponent implements OnChanges, OnInit, AfterViewInit, ControlValueAccessor {
    readonly classes: string;
    readonly config: NgSelectConfig;
    private readonly _cd;
    private readonly _console;
    private readonly _destroyRef;
    readonly _disabled: _angular_core.WritableSignal<boolean>;
    readonly ariaLabelDropdown: _angular_core.InputSignal<string>;
    readonly ariaLabel: _angular_core.InputSignal<string>;
    readonly markFirst: _angular_core.InputSignalWithTransform<boolean, unknown>;
    readonly placeholder: _angular_core.InputSignal<string>;
    readonly fixedPlaceholder: _angular_core.InputSignal<boolean>;
    readonly notFoundText: _angular_core.InputSignal<string>;
    readonly typeToSearchText: _angular_core.InputSignal<string>;
    readonly preventToggleOnRightClick: _angular_core.InputSignal<boolean>;
    readonly addTagText: _angular_core.InputSignal<string>;
    readonly loadingText: _angular_core.InputSignal<string>;
    readonly clearAllText: _angular_core.InputSignal<string>;
    readonly dropdownPosition: _angular_core.InputSignal<DropdownPosition>;
    readonly appendTo: _angular_core.InputSignal<string>;
    readonly outsideClickEvent: _angular_core.InputSignal<"click" | "mousedown">;
    readonly loading: _angular_core.InputSignalWithTransform<boolean, unknown>;
    readonly closeOnSelect: _angular_core.InputSignalWithTransform<boolean, unknown>;
    readonly hideSelected: _angular_core.InputSignalWithTransform<boolean, unknown>;
    readonly selectOnTab: _angular_core.InputSignalWithTransform<boolean, unknown>;
    readonly openOnEnter: _angular_core.InputSignalWithTransform<boolean, unknown>;
    readonly maxSelectedItems: _angular_core.InputSignalWithTransform<number, unknown>;
    readonly groupBy: _angular_core.InputSignal<string | ((value: any) => any)>;
    readonly groupValue: _angular_core.InputSignal<GroupValueFn>;
    readonly bufferAmount: _angular_core.InputSignalWithTransform<number, unknown>;
    readonly virtualScroll: _angular_core.InputSignalWithTransform<boolean, unknown>;
    readonly selectableGroup: _angular_core.InputSignalWithTransform<boolean, unknown>;
    readonly tabFocusOnClearButton: _angular_core.InputSignal<boolean>;
    readonly selectableGroupAsModel: _angular_core.InputSignalWithTransform<boolean, unknown>;
    readonly searchFn: _angular_core.InputSignal<any>;
    readonly trackByFn: _angular_core.InputSignal<any>;
    readonly clearOnBackspace: _angular_core.InputSignalWithTransform<boolean, unknown>;
    readonly labelForId: _angular_core.InputSignal<any>;
    readonly inputAttrs: _angular_core.InputSignal<Record<string, string>>;
    readonly tabIndex: _angular_core.InputSignalWithTransform<number, unknown>;
    readonly readonly: _angular_core.InputSignalWithTransform<boolean, unknown>;
    readonly searchWhileComposing: _angular_core.InputSignalWithTransform<boolean, unknown>;
    readonly minTermLength: _angular_core.InputSignalWithTransform<number, unknown>;
    readonly editableSearchTerm: _angular_core.InputSignalWithTransform<boolean, unknown>;
    readonly ngClass: _angular_core.InputSignal<any>;
    readonly typeahead: _angular_core.InputSignal<Subject<string>>;
    readonly multiple: _angular_core.InputSignalWithTransform<boolean, unknown>;
    readonly addTag: _angular_core.InputSignal<boolean | AddTagFn>;
    readonly searchable: _angular_core.InputSignalWithTransform<boolean, unknown>;
    readonly clearable: _angular_core.InputSignalWithTransform<boolean, unknown>;
    readonly deselectOnClick: _angular_core.InputSignal<boolean>;
    readonly clearSearchOnAdd: _angular_core.InputSignal<any>;
    readonly compareWith: _angular_core.InputSignalWithTransform<CompareWithFn, CompareWithFn>;
    readonly keyDownFn: _angular_core.InputSignal<(_: KeyboardEvent) => boolean>;
    readonly bindLabel: _angular_core.ModelSignal<string>;
    readonly bindValue: _angular_core.ModelSignal<string>;
    readonly appearance: _angular_core.ModelSignal<string>;
    readonly isOpen: _angular_core.ModelSignal<boolean>;
    readonly items: _angular_core.ModelSignal<readonly any[]>;
    readonly blurEvent: _angular_core.OutputEmitterRef<any>;
    readonly focusEvent: _angular_core.OutputEmitterRef<any>;
    readonly changeEvent: _angular_core.OutputEmitterRef<any>;
    readonly openEvent: _angular_core.OutputEmitterRef<void>;
    readonly closeEvent: _angular_core.OutputEmitterRef<void>;
    readonly searchEvent: _angular_core.OutputEmitterRef<{
        term: string;
        items: any[];
    }>;
    readonly clearEvent: _angular_core.OutputEmitterRef<void>;
    readonly addEvent: _angular_core.OutputEmitterRef<any>;
    readonly removeEvent: _angular_core.OutputEmitterRef<any>;
    readonly scroll: _angular_core.OutputEmitterRef<{
        start: number;
        end: number;
    }>;
    readonly scrollToEnd: _angular_core.OutputEmitterRef<any>;
    readonly disabled: _angular_core.Signal<boolean>;
    readonly clearSearchOnAddValue: _angular_core.Signal<any>;
    readonly deselectOnClickValue: _angular_core.Signal<boolean>;
    readonly optionTemplate: _angular_core.Signal<TemplateRef<any>>;
    readonly optgroupTemplate: _angular_core.Signal<TemplateRef<any>>;
    readonly labelTemplate: _angular_core.Signal<TemplateRef<any>>;
    readonly multiLabelTemplate: _angular_core.Signal<TemplateRef<any>>;
    readonly headerTemplate: _angular_core.Signal<TemplateRef<any>>;
    readonly footerTemplate: _angular_core.Signal<TemplateRef<any>>;
    readonly notFoundTemplate: _angular_core.Signal<TemplateRef<any>>;
    readonly placeholderTemplate: _angular_core.Signal<TemplateRef<any>>;
    readonly typeToSearchTemplate: _angular_core.Signal<TemplateRef<any>>;
    readonly loadingTextTemplate: _angular_core.Signal<TemplateRef<any>>;
    readonly tagTemplate: _angular_core.Signal<TemplateRef<any>>;
    readonly loadingSpinnerTemplate: _angular_core.Signal<TemplateRef<any>>;
    readonly clearButtonTemplate: _angular_core.Signal<TemplateRef<any>>;
    readonly ngOptions: _angular_core.Signal<readonly NgOptionComponent[]>;
    readonly dropdownPanel: _angular_core.Signal<any>;
    readonly searchInput: _angular_core.Signal<ElementRef<HTMLInputElement>>;
    readonly clearButton: _angular_core.Signal<ElementRef<HTMLSpanElement>>;
    readonly dropdownId: string;
    readonly element: HTMLElement;
    escapeHTML: boolean;
    itemsList: ItemsList;
    viewPortItems: NgOption[];
    tabFocusOnClear: _angular_core.WritableSignal<boolean>;
    private readonly autoFocus;
    private readonly _defaultLabel;
    private readonly _editableSearchTerm;
    private _focused;
    private _injector;
    private _isComposing;
    private _itemsAreUsed;
    private readonly _keyPress$;
    private _manualOpen;
    private _pressedKeys;
    private _primitive;
    private readonly _searchTerm;
    private readonly _validTerm;
    constructor();
    get filtered(): boolean;
    get focused(): boolean;
    get searchTerm(): string;
    get selectedItems(): NgOption[];
    get selectedValues(): any[];
    get hasValue(): boolean;
    get currentPanelPosition(): DropdownPosition;
    get showAddTag(): boolean;
    clearItem: (item: any) => void;
    ngOnInit(): void;
    ngOnChanges(changes: SimpleChanges): void;
    ngAfterViewInit(): void;
    handleKeyDown($event: KeyboardEvent): void;
    handleKeyCode($event: KeyboardEvent): void;
    handleKeyCodeInput($event: KeyboardEvent): void;
    handleKeyCodeClear($event: KeyboardEvent): void;
    handleMousedown($event: MouseEvent): boolean;
    handleArrowClick(): void;
    handleClearClick(_event?: MouseEvent): void;
    clearModel(): void;
    writeValue(value: any | any[]): void;
    registerOnChange(fn: any): void;
    registerOnTouched(fn: any): void;
    setDisabledState(state: boolean): void;
    toggle(): void;
    open(): void;
    close(): void;
    toggleItem(item: NgOption): void;
    select(item: NgOption): void;
    focus(): void;
    blur(): void;
    unselect(item: NgOption): void;
    selectTag(): void;
    showClear(): boolean;
    focusOnClear(): void;
    trackByOption: (_: number, item: NgOption) => any;
    showNoItemsFound(): boolean;
    showTypeToSearch(): boolean;
    onCompositionStart(): void;
    onCompositionEnd(term: string): void;
    filter(term: string): void;
    onInputFocus($event: FocusEvent): void;
    onInputBlur($event: FocusEvent): void;
    onItemHover(item: NgOption): void;
    detectChanges(): void;
    private _onChange;
    private _onTouched;
    private _setSearchTermFromItems;
    private _setItems;
    private _setItemsFromNgOptions;
    private _isValidWriteValue;
    private _handleWriteValue;
    private _handleKeyPresses;
    private _setInputAttributes;
    private _setTabFocusOnClear;
    private _updateNgModel;
    private _clearSearch;
    private _changeSearch;
    private _scrollToMarked;
    private _scrollToTag;
    private _onSelectionChanged;
    private _handleTab;
    private _handleEnter;
    private _handleSpace;
    private _handleArrowDown;
    private _handleArrowUp;
    private _nextItemIsTag;
    private _handleBackspace;
    private _mergeGlobalConfig;
    /**
     * Gets virtual scroll value from input or from config
     *
     *  @param config NgSelectConfig object
     *
     *  @returns `true` if virtual scroll is enabled, `false` otherwise
     */
    private getVirtualScroll;
    /**
     * Gets disableVirtualScroll value from input or from config
     *
     *  @param config NgSelectConfig object
     *
     *  @returns `true` if disableVirtualScroll is enabled, `false` otherwise
     */
    private isVirtualScrollDisabled;
    static ɵfac: _angular_core.ɵɵFactoryDeclaration<NgSelectComponent, never>;
    static ɵcmp: _angular_core.ɵɵComponentDeclaration<NgSelectComponent, "ng-select", ["ngSelect"], { "ariaLabelDropdown": { "alias": "ariaLabelDropdown"; "required": false; "isSignal": true; }; "ariaLabel": { "alias": "ariaLabel"; "required": false; "isSignal": true; }; "markFirst": { "alias": "markFirst"; "required": false; "isSignal": true; }; "placeholder": { "alias": "placeholder"; "required": false; "isSignal": true; }; "fixedPlaceholder": { "alias": "fixedPlaceholder"; "required": false; "isSignal": true; }; "notFoundText": { "alias": "notFoundText"; "required": false; "isSignal": true; }; "typeToSearchText": { "alias": "typeToSearchText"; "required": false; "isSignal": true; }; "preventToggleOnRightClick": { "alias": "preventToggleOnRightClick"; "required": false; "isSignal": true; }; "addTagText": { "alias": "addTagText"; "required": false; "isSignal": true; }; "loadingText": { "alias": "loadingText"; "required": false; "isSignal": true; }; "clearAllText": { "alias": "clearAllText"; "required": false; "isSignal": true; }; "dropdownPosition": { "alias": "dropdownPosition"; "required": false; "isSignal": true; }; "appendTo": { "alias": "appendTo"; "required": false; "isSignal": true; }; "outsideClickEvent": { "alias": "outsideClickEvent"; "required": false; "isSignal": true; }; "loading": { "alias": "loading"; "required": false; "isSignal": true; }; "closeOnSelect": { "alias": "closeOnSelect"; "required": false; "isSignal": true; }; "hideSelected": { "alias": "hideSelected"; "required": false; "isSignal": true; }; "selectOnTab": { "alias": "selectOnTab"; "required": false; "isSignal": true; }; "openOnEnter": { "alias": "openOnEnter"; "required": false; "isSignal": true; }; "maxSelectedItems": { "alias": "maxSelectedItems"; "required": false; "isSignal": true; }; "groupBy": { "alias": "groupBy"; "required": false; "isSignal": true; }; "groupValue": { "alias": "groupValue"; "required": false; "isSignal": true; }; "bufferAmount": { "alias": "bufferAmount"; "required": false; "isSignal": true; }; "virtualScroll": { "alias": "virtualScroll"; "required": false; "isSignal": true; }; "selectableGroup": { "alias": "selectableGroup"; "required": false; "isSignal": true; }; "tabFocusOnClearButton": { "alias": "tabFocusOnClearButton"; "required": false; "isSignal": true; }; "selectableGroupAsModel": { "alias": "selectableGroupAsModel"; "required": false; "isSignal": true; }; "searchFn": { "alias": "searchFn"; "required": false; "isSignal": true; }; "trackByFn": { "alias": "trackByFn"; "required": false; "isSignal": true; }; "clearOnBackspace": { "alias": "clearOnBackspace"; "required": false; "isSignal": true; }; "labelForId": { "alias": "labelForId"; "required": false; "isSignal": true; }; "inputAttrs": { "alias": "inputAttrs"; "required": false; "isSignal": true; }; "tabIndex": { "alias": "tabIndex"; "required": false; "isSignal": true; }; "readonly": { "alias": "readonly"; "required": false; "isSignal": true; }; "searchWhileComposing": { "alias": "searchWhileComposing"; "required": false; "isSignal": true; }; "minTermLength": { "alias": "minTermLength"; "required": false; "isSignal": true; }; "editableSearchTerm": { "alias": "editableSearchTerm"; "required": false; "isSignal": true; }; "ngClass": { "alias": "ngClass"; "required": false; "isSignal": true; }; "typeahead": { "alias": "typeahead"; "required": false; "isSignal": true; }; "multiple": { "alias": "multiple"; "required": false; "isSignal": true; }; "addTag": { "alias": "addTag"; "required": false; "isSignal": true; }; "searchable": { "alias": "searchable"; "required": false; "isSignal": true; }; "clearable": { "alias": "clearable"; "required": false; "isSignal": true; }; "deselectOnClick": { "alias": "deselectOnClick"; "required": false; "isSignal": true; }; "clearSearchOnAdd": { "alias": "clearSearchOnAdd"; "required": false; "isSignal": true; }; "compareWith": { "alias": "compareWith"; "required": false; "isSignal": true; }; "keyDownFn": { "alias": "keyDownFn"; "required": false; "isSignal": true; }; "bindLabel": { "alias": "bindLabel"; "required": false; "isSignal": true; }; "bindValue": { "alias": "bindValue"; "required": false; "isSignal": true; }; "appearance": { "alias": "appearance"; "required": false; "isSignal": true; }; "isOpen": { "alias": "isOpen"; "required": false; "isSignal": true; }; "items": { "alias": "items"; "required": false; "isSignal": true; }; }, { "bindLabel": "bindLabelChange"; "bindValue": "bindValueChange"; "appearance": "appearanceChange"; "isOpen": "isOpenChange"; "items": "itemsChange"; "blurEvent": "blur"; "focusEvent": "focus"; "changeEvent": "change"; "openEvent": "open"; "closeEvent": "close"; "searchEvent": "search"; "clearEvent": "clear"; "addEvent": "add"; "removeEvent": "remove"; "scroll": "scroll"; "scrollToEnd": "scrollToEnd"; }, ["optionTemplate", "optgroupTemplate", "labelTemplate", "multiLabelTemplate", "headerTemplate", "footerTemplate", "notFoundTemplate", "placeholderTemplate", "typeToSearchTemplate", "loadingTextTemplate", "tagTemplate", "loadingSpinnerTemplate", "clearButtonTemplate", "ngOptions"], never, true, never>;
}

declare class NgDropdownPanelComponent implements OnInit, OnChanges {
    readonly items: _angular_core.InputSignal<NgOption[]>;
    readonly showAddTag: _angular_core.InputSignalWithTransform<boolean, unknown>;
    readonly markedItem: _angular_core.InputSignal<NgOption>;
    readonly position: _angular_core.InputSignal<DropdownPosition>;
    readonly appendTo: _angular_core.InputSignal<string>;
    readonly bufferAmount: _angular_core.InputSignal<number>;
    readonly virtualScroll: _angular_core.InputSignalWithTransform<boolean, unknown>;
    readonly headerTemplate: _angular_core.InputSignal<TemplateRef<any>>;
    readonly footerTemplate: _angular_core.InputSignal<TemplateRef<any>>;
    readonly filterValue: _angular_core.InputSignal<string>;
    readonly ariaLabelDropdown: _angular_core.InputSignal<string>;
    /**
     * Which DOM event to listen to for outside click detection
     */
    readonly outsideClickEvent: _angular_core.InputSignal<"click" | "mousedown">;
    readonly update: _angular_core.OutputEmitterRef<any[]>;
    readonly scroll: _angular_core.OutputEmitterRef<{
        start: number;
        end: number;
    }>;
    readonly scrollToEnd: _angular_core.OutputEmitterRef<void>;
    readonly outsideClick: _angular_core.OutputEmitterRef<void>;
    private _renderer;
    private _zone;
    private _panelService;
    private _document;
    private _destroyRef;
    private _dropdown;
    private readonly contentElementRef;
    private readonly scrollElementRef;
    private readonly paddingElementRef;
    private readonly _virtualPadding;
    private readonly _scrollablePanel;
    private readonly _contentPanel;
    private _select;
    private _parent;
    private _scrollToEndFired;
    private _updateScrollHeight;
    private _lastScrollPosition;
    constructor();
    private _currentPosition;
    get currentPosition(): DropdownPosition;
    private _itemsLength;
    private get itemsLength();
    private set itemsLength(value);
    private get _startOffset();
    ngOnInit(): void;
    ngOnChanges(changes: SimpleChanges): void;
    scrollTo(option: NgOption, startFromOption?: boolean): void;
    scrollToTag(): void;
    adjustPosition(): void;
    private _handleDropdownPosition;
    private _updateDropdownClass;
    private _handleScroll;
    private _handleOutsideClick;
    private _checkToClose;
    private _onItemsOrShowAddTagChange;
    private _updateItems;
    private _updateItemsRange;
    private _onContentScrolled;
    private _updateVirtualHeight;
    private _setVirtualHeight;
    private _onItemsLengthChanged;
    private _renderItemsRange;
    private _measureDimensions;
    private _fireScrollToEnd;
    private _calculateCurrentPosition;
    private _appendDropdown;
    private _updateXPosition;
    private _updateYPosition;
    private _setupMousedownListener;
    static ɵfac: _angular_core.ɵɵFactoryDeclaration<NgDropdownPanelComponent, never>;
    static ɵcmp: _angular_core.ɵɵComponentDeclaration<NgDropdownPanelComponent, "ng-dropdown-panel", never, { "items": { "alias": "items"; "required": false; "isSignal": true; }; "showAddTag": { "alias": "showAddTag"; "required": false; "isSignal": true; }; "markedItem": { "alias": "markedItem"; "required": false; "isSignal": true; }; "position": { "alias": "position"; "required": false; "isSignal": true; }; "appendTo": { "alias": "appendTo"; "required": false; "isSignal": true; }; "bufferAmount": { "alias": "bufferAmount"; "required": false; "isSignal": true; }; "virtualScroll": { "alias": "virtualScroll"; "required": false; "isSignal": true; }; "headerTemplate": { "alias": "headerTemplate"; "required": false; "isSignal": true; }; "footerTemplate": { "alias": "footerTemplate"; "required": false; "isSignal": true; }; "filterValue": { "alias": "filterValue"; "required": false; "isSignal": true; }; "ariaLabelDropdown": { "alias": "ariaLabelDropdown"; "required": false; "isSignal": true; }; "outsideClickEvent": { "alias": "outsideClickEvent"; "required": false; "isSignal": true; }; }, { "update": "update"; "scroll": "scroll"; "scrollToEnd": "scrollToEnd"; "outsideClick": "outsideClick"; }, never, ["*"], true, never>;
}

declare class NgItemLabelDirective {
    private element;
    ngItemLabel: _angular_core.InputSignal<string>;
    escape: _angular_core.InputSignal<boolean>;
    constructor();
    static ɵfac: _angular_core.ɵɵFactoryDeclaration<NgItemLabelDirective, never>;
    static ɵdir: _angular_core.ɵɵDirectiveDeclaration<NgItemLabelDirective, "[ngItemLabel]", never, { "ngItemLabel": { "alias": "ngItemLabel"; "required": false; "isSignal": true; }; "escape": { "alias": "escape"; "required": false; "isSignal": true; }; }, {}, never, never, true, never>;
}
declare class NgOptionTemplateDirective {
    readonly template: TemplateRef<any>;
    static ɵfac: _angular_core.ɵɵFactoryDeclaration<NgOptionTemplateDirective, never>;
    static ɵdir: _angular_core.ɵɵDirectiveDeclaration<NgOptionTemplateDirective, "[ng-option-tmp]", never, {}, {}, never, never, true, never>;
}
declare class NgOptgroupTemplateDirective {
    readonly template: TemplateRef<any>;
    static ɵfac: _angular_core.ɵɵFactoryDeclaration<NgOptgroupTemplateDirective, never>;
    static ɵdir: _angular_core.ɵɵDirectiveDeclaration<NgOptgroupTemplateDirective, "[ng-optgroup-tmp]", never, {}, {}, never, never, true, never>;
}
declare class NgLabelTemplateDirective {
    readonly template: TemplateRef<any>;
    static ɵfac: _angular_core.ɵɵFactoryDeclaration<NgLabelTemplateDirective, never>;
    static ɵdir: _angular_core.ɵɵDirectiveDeclaration<NgLabelTemplateDirective, "[ng-label-tmp]", never, {}, {}, never, never, true, never>;
}
declare class NgMultiLabelTemplateDirective {
    readonly template: TemplateRef<any>;
    static ɵfac: _angular_core.ɵɵFactoryDeclaration<NgMultiLabelTemplateDirective, never>;
    static ɵdir: _angular_core.ɵɵDirectiveDeclaration<NgMultiLabelTemplateDirective, "[ng-multi-label-tmp]", never, {}, {}, never, never, true, never>;
}
declare class NgHeaderTemplateDirective {
    readonly template: TemplateRef<any>;
    static ɵfac: _angular_core.ɵɵFactoryDeclaration<NgHeaderTemplateDirective, never>;
    static ɵdir: _angular_core.ɵɵDirectiveDeclaration<NgHeaderTemplateDirective, "[ng-header-tmp]", never, {}, {}, never, never, true, never>;
}
declare class NgFooterTemplateDirective {
    readonly template: TemplateRef<any>;
    static ɵfac: _angular_core.ɵɵFactoryDeclaration<NgFooterTemplateDirective, never>;
    static ɵdir: _angular_core.ɵɵDirectiveDeclaration<NgFooterTemplateDirective, "[ng-footer-tmp]", never, {}, {}, never, never, true, never>;
}
declare class NgNotFoundTemplateDirective {
    readonly template: TemplateRef<any>;
    static ɵfac: _angular_core.ɵɵFactoryDeclaration<NgNotFoundTemplateDirective, never>;
    static ɵdir: _angular_core.ɵɵDirectiveDeclaration<NgNotFoundTemplateDirective, "[ng-notfound-tmp]", never, {}, {}, never, never, true, never>;
}
declare class NgPlaceholderTemplateDirective {
    readonly template: TemplateRef<any>;
    static ɵfac: _angular_core.ɵɵFactoryDeclaration<NgPlaceholderTemplateDirective, never>;
    static ɵdir: _angular_core.ɵɵDirectiveDeclaration<NgPlaceholderTemplateDirective, "[ng-placeholder-tmp]", never, {}, {}, never, never, true, never>;
}
declare class NgTypeToSearchTemplateDirective {
    readonly template: TemplateRef<any>;
    static ɵfac: _angular_core.ɵɵFactoryDeclaration<NgTypeToSearchTemplateDirective, never>;
    static ɵdir: _angular_core.ɵɵDirectiveDeclaration<NgTypeToSearchTemplateDirective, "[ng-typetosearch-tmp]", never, {}, {}, never, never, true, never>;
}
declare class NgLoadingTextTemplateDirective {
    readonly template: TemplateRef<any>;
    static ɵfac: _angular_core.ɵɵFactoryDeclaration<NgLoadingTextTemplateDirective, never>;
    static ɵdir: _angular_core.ɵɵDirectiveDeclaration<NgLoadingTextTemplateDirective, "[ng-loadingtext-tmp]", never, {}, {}, never, never, true, never>;
}
declare class NgTagTemplateDirective {
    readonly template: TemplateRef<any>;
    static ɵfac: _angular_core.ɵɵFactoryDeclaration<NgTagTemplateDirective, never>;
    static ɵdir: _angular_core.ɵɵDirectiveDeclaration<NgTagTemplateDirective, "[ng-tag-tmp]", never, {}, {}, never, never, true, never>;
}
declare class NgLoadingSpinnerTemplateDirective {
    readonly template: TemplateRef<any>;
    static ɵfac: _angular_core.ɵɵFactoryDeclaration<NgLoadingSpinnerTemplateDirective, never>;
    static ɵdir: _angular_core.ɵɵDirectiveDeclaration<NgLoadingSpinnerTemplateDirective, "[ng-loadingspinner-tmp]", never, {}, {}, never, never, true, never>;
}
declare class NgClearButtonTemplateDirective {
    readonly template: TemplateRef<any>;
    static ɵfac: _angular_core.ɵɵFactoryDeclaration<NgClearButtonTemplateDirective, never>;
    static ɵdir: _angular_core.ɵɵDirectiveDeclaration<NgClearButtonTemplateDirective, "[ng-clearbutton-tmp]", never, {}, {}, never, never, true, never>;
}

declare class NgSelectModule {
    static ɵfac: _angular_core.ɵɵFactoryDeclaration<NgSelectModule, never>;
    static ɵmod: _angular_core.ɵɵNgModuleDeclaration<NgSelectModule, never, [typeof NgDropdownPanelComponent, typeof NgOptionComponent, typeof NgSelectComponent, typeof NgOptgroupTemplateDirective, typeof NgOptionTemplateDirective, typeof NgLabelTemplateDirective, typeof NgMultiLabelTemplateDirective, typeof NgHeaderTemplateDirective, typeof NgFooterTemplateDirective, typeof NgPlaceholderTemplateDirective, typeof NgClearButtonTemplateDirective, typeof NgNotFoundTemplateDirective, typeof NgTypeToSearchTemplateDirective, typeof NgLoadingTextTemplateDirective, typeof NgTagTemplateDirective, typeof NgLoadingSpinnerTemplateDirective, typeof NgItemLabelDirective], [typeof NgSelectComponent, typeof NgOptionComponent, typeof NgOptgroupTemplateDirective, typeof NgOptionTemplateDirective, typeof NgLabelTemplateDirective, typeof NgMultiLabelTemplateDirective, typeof NgHeaderTemplateDirective, typeof NgFooterTemplateDirective, typeof NgPlaceholderTemplateDirective, typeof NgNotFoundTemplateDirective, typeof NgTypeToSearchTemplateDirective, typeof NgLoadingTextTemplateDirective, typeof NgTagTemplateDirective, typeof NgLoadingSpinnerTemplateDirective, typeof NgClearButtonTemplateDirective]>;
    static ɵinj: _angular_core.ɵɵInjectorDeclaration<NgSelectModule>;
}

declare class ConsoleService {
    warn(message: string): void;
    static ɵfac: _angular_core.ɵɵFactoryDeclaration<ConsoleService, never>;
    static ɵprov: _angular_core.ɵɵInjectableDeclaration<ConsoleService>;
}

interface ItemsRangeResult {
    scrollHeight: number;
    topPadding: number;
    start: number;
    end: number;
}
interface PanelDimensions {
    itemHeight: number;
    panelHeight: number;
    itemsPerViewport: number;
}
declare class NgDropdownPanelService {
    private _dimensions;
    get dimensions(): PanelDimensions;
    calculateItems(scrollPos: number, itemsLength: number, buffer: number): ItemsRangeResult;
    setDimensions(itemHeight: number, panelHeight: number): void;
    getScrollTo(itemTop: number, itemHeight: number, lastScroll: number): number;
    static ɵfac: _angular_core.ɵɵFactoryDeclaration<NgDropdownPanelService, never>;
    static ɵprov: _angular_core.ɵɵInjectableDeclaration<NgDropdownPanelService>;
}

export { ConsoleService, DefaultSelectionModel, DefaultSelectionModelFactory, NgClearButtonTemplateDirective, NgDropdownPanelComponent, NgDropdownPanelService, NgFooterTemplateDirective, NgHeaderTemplateDirective, NgItemLabelDirective, NgLabelTemplateDirective, NgLoadingSpinnerTemplateDirective, NgLoadingTextTemplateDirective, NgMultiLabelTemplateDirective, NgNotFoundTemplateDirective, NgOptgroupTemplateDirective, NgOptionComponent, NgOptionTemplateDirective, NgPlaceholderTemplateDirective, NgSelectComponent, NgSelectConfig, NgSelectModule, NgTagTemplateDirective, NgTypeToSearchTemplateDirective, SELECTION_MODEL_FACTORY };
export type { DropdownPosition, NgOption, SelectionModel };
